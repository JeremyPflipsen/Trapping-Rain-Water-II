{"ast":null,"code":"function Node(row, col) {\n  return document.getElementById(`node-${row}-${col}`);\n} // Gets a node from the screen\n\n\nfunction getImmutableSquares(mutable) {\n  let count = 0;\n  let immutableSquares = [];\n  let squareRow = 0;\n  let squareCol = 0;\n\n  for (let square = 0; square < 9; square++) {\n    for (let row = squareRow; row < 3 + squareRow; row++) {\n      for (let col = squareCol; col < 3 + squareCol; col++) {\n        if (!mutable[row][col]) {\n          count++;\n        }\n      }\n    }\n\n    if (count >= 8) {\n      immutableSquares.push([squareRow, squareCol]);\n    }\n\n    count = 0;\n\n    if (squareCol !== 6) {\n      squareCol = squareCol + 3;\n    } else {\n      squareCol = 0;\n      squareRow = squareRow + 3;\n    }\n  }\n\n  return immutableSquares;\n}\n\nfunction getRandomInt(max) {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n\nfunction randomGrid(grid, mutable) {\n  //copy array because pass by reference and setState are fucking dumb\n  let tempGrid = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];\n\n  for (let row = 0; row < 9; row++) {\n    for (let col = 0; col < 9; col++) {\n      tempGrid[row][col] = grid[row][col];\n    }\n  }\n\n  for (let row = 0; row < 9; row++) {\n    for (let col = 0; col < 9; col++) {\n      if (mutable[row][col]) {\n        tempGrid[row][col] = getRandomInt(9) + 1;\n      }\n    }\n  }\n\n  return tempGrid;\n}\n\nfunction error(grid) {\n  let E = 0;\n  let seen = [];\n  let squareRow = 0;\n  let squareCol = 0; //check the rows\n\n  for (let row = 0; row < 9; row++) {\n    for (let col = 0; col < 9; col++) {\n      if (seen.includes(grid[row][col])) {\n        E = E + 1;\n      } else {\n        seen.push(grid[row][col]);\n      }\n    }\n\n    seen = [];\n  } //check the columns\n\n\n  for (let col = 0; col < 9; col++) {\n    for (let row = 0; row < 9; row++) {\n      if (seen.includes(grid[row][col])) {\n        E = E + 1;\n      } else {\n        seen.push(grid[row][col]);\n      }\n    }\n\n    seen = [];\n  } //Check the squares\n\n\n  for (let square = 0; square < 9; square++) {\n    for (let row = squareRow; row < 3 + squareRow; row++) {\n      for (let col = squareCol; col < 3 + squareCol; col++) {\n        if (seen.includes(grid[row][col])) {\n          E = E + 1;\n        } else {\n          seen.push(grid[row][col]);\n        }\n      }\n    }\n\n    if (squareCol !== 6) {\n      squareCol = squareCol + 3;\n    } else {\n      squareCol = 0;\n      squareRow = squareRow + 3;\n    }\n\n    seen = [];\n  }\n\n  return E;\n}\n\nfunction solve(grid, moves, mutable) {\n  //check if any squares have 8 or 9 immutables\n  let immutableSquares = getImmutableSquares(mutable);\n\n  if (immutableSquares.length === 9) {\n    document.getElementById('Error').innerHTML = 'Trivial solution detected.';\n    return;\n  } //Step 1: initialize population\n\n\n  let Cpopulation = [];\n  let N = 100; //population size\n\n  for (let i = 0; i < N; i++) {\n    //create random individual\n    Cpopulation.push(randomGrid(grid, mutable));\n  } //Step 2: Selection\n  //Create reproductive population\n\n\n  let fitness = [];\n  let Rpopulation = [];\n\n  for (let i = 0; i < N; i++) {\n    //evaluate error of each individual\n    //add individual to reproductive population according to its error\n    fitness.push(216 - error(Cpopulation[i]) - 100); //Maximum error is 81*3-9*3 = 216. fitnesses never go below 100 so this -100 makes good fitness more significant\n\n    for (let j = 0; j < fitness[i]; j++) {\n      Rpopulation.push(i);\n    }\n  } //Step 3: Reproduction\n  //create new population from current reproductive population\n\n\n  let parent1 = -1;\n  let parent2 = -1;\n\n  for (let i = 0; i < N; i++) {\n    //choose two random parents\n    parent1 = Rpopulation[getRandomInt(Rpopulation.length) + 1];\n    parent2 = Rpopulation[getRandomInt(Rpopulation.length) + 1];\n\n    while (parent2 === parent1) {\n      parent2 = getRandomInt(Rpopulation.length) + 1;\n    }\n\n    console.log(parent1, parent2); //mix their info\n    // let Npopulation = []\n    // for (let i = 0; i < N; i ++) {\n    //     let tempGrid = [\n    //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    //         [0, 0, 0, 0, 0, 0, 0, 0, 0]\n    //     ]\n    //     for (let row = 0; row < 9; row++) {\n    //         for (let col= 0; col< 9; col++){\n    //             if (mutable[row][col]) {\n    //                 if (Math.random > 0.5) {\n    //                     tempGrid[row][col] = Cpopulation[parent1][row][col]\n    //                 }\n    //                else {\n    //                    tempGrid[row][col] = Cpopulation[parent2][row][col]\n    //                } \n    //             }\n    //         }\n    //     }\n    //     Npopulation.push(tempGrid)\n    // }\n    // moves=Npopulation\n    //mutate\n  }\n}\n\nexport default function geneticAlgorithm(grid) {\n  let mutable = []; //Prevents the algorithm from changing original node values\n\n  for (let row = 0; row < 9; row++) {\n    let temp = [];\n\n    for (let col = 0; col < 9; col++) {\n      if (grid[row][col] === 0 || grid[row][col] === '0') {\n        temp.push(true);\n      } else {\n        temp.push(false);\n      }\n    }\n\n    mutable.push(temp);\n  } //a list of the moves the algorithm will take\n\n\n  let moves = [];\n  solve(grid, moves, mutable);\n  return moves;\n}","map":{"version":3,"sources":["C:/Users/hp/Desktop/Sudoku/my-app/src/algorithms/geneticAlgorithm.js"],"names":["Node","row","col","document","getElementById","getImmutableSquares","mutable","count","immutableSquares","squareRow","squareCol","square","push","getRandomInt","max","Math","floor","random","randomGrid","grid","tempGrid","error","E","seen","includes","solve","moves","length","innerHTML","Cpopulation","N","i","fitness","Rpopulation","j","parent1","parent2","console","log","geneticAlgorithm","temp"],"mappings":"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","sourcesContent":["\r\n\r\nfunction Node(row, col) {\r\n    return document.getElementById(`node-${row}-${col}`)\r\n} // Gets a node from the screen\r\n\r\nfunction getImmutableSquares(mutable) {\r\n    let count = 0\r\n    let immutableSquares = []\r\n    let squareRow = 0\r\n    let squareCol = 0\r\n\r\n    for (let square = 0; square < 9; square++) {\r\n        for (let row = squareRow; row<3+squareRow; row++) {\r\n            for (let col = squareCol; col < 3+squareCol; col++) {\r\n                if (!mutable[row][col]){\r\n                    count++\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (count >= 8) {\r\n            immutableSquares.push([squareRow,squareCol])\r\n        }\r\n\r\n        count = 0\r\n\r\n        if (squareCol !== 6) {\r\n            squareCol = squareCol + 3\r\n        }\r\n        else {\r\n            squareCol = 0\r\n            squareRow = squareRow + 3\r\n        }\r\n    }\r\n\r\n    return immutableSquares\r\n}\r\n\r\nfunction getRandomInt(max) {\r\n    return Math.floor(Math.random() * Math.floor(max));\r\n}\r\n\r\nfunction randomGrid(grid,mutable) {\r\n    //copy array because pass by reference and setState are fucking dumb\r\n    let tempGrid = [\r\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        [0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n    ]\r\n\r\n    for (let row = 0; row < 9; row++) {\r\n        for (let col= 0; col< 9; col++){\r\n            tempGrid[row][col] = grid[row][col]\r\n        }\r\n    }\r\n\r\n    for (let row = 0; row < 9; row++) {\r\n        for (let col= 0; col< 9; col++){\r\n            if (mutable[row][col]) {\r\n                tempGrid[row][col] = getRandomInt(9) +1\r\n            }\r\n        }\r\n    }\r\n    return tempGrid\r\n}\r\n\r\nfunction error(grid) {\r\n    let E = 0\r\n    let seen = []\r\n    let squareRow = 0\r\n    let squareCol = 0\r\n\r\n    //check the rows\r\n    for (let row = 0; row < 9; row ++) {\r\n        for (let col = 0; col < 9; col ++) {\r\n            if (seen.includes(grid[row][col])) {\r\n                E = E + 1\r\n            }\r\n            else {\r\n                seen.push(grid[row][col])\r\n            }\r\n        }\r\n        seen = []\r\n    }\r\n    //check the columns\r\n    for (let col = 0; col < 9; col ++) {\r\n        for (let row = 0; row < 9; row ++) {\r\n            if (seen.includes(grid[row][col])) {\r\n                E = E + 1\r\n            }\r\n            else {\r\n                seen.push(grid[row][col])\r\n            }\r\n        }\r\n        seen = []\r\n    }\r\n    //Check the squares\r\n    for (let square = 0; square < 9; square++) {\r\n        for (let row = squareRow; row<3+squareRow; row++) {\r\n            for (let col = squareCol; col < 3+squareCol; col++) {\r\n                if (seen.includes(grid[row][col])) {\r\n                    E = E + 1\r\n                }\r\n                else {\r\n                    seen.push(grid[row][col])\r\n                }\r\n            }\r\n        }\r\n        if (squareCol !== 6) {\r\n            squareCol = squareCol + 3\r\n        }\r\n        else {\r\n            squareCol = 0\r\n            squareRow = squareRow + 3\r\n        }\r\n\r\n        seen = []\r\n    }\r\n\r\n    return E\r\n}\r\n\r\nfunction solve(grid, moves, mutable) {\r\n    //check if any squares have 8 or 9 immutables\r\n    let immutableSquares = getImmutableSquares(mutable)\r\n    if (immutableSquares.length === 9){\r\n        document.getElementById('Error').innerHTML = 'Trivial solution detected.'\r\n        return\r\n    }\r\n\r\n    //Step 1: initialize population\r\n    let Cpopulation = []\r\n    let N = 100 //population size\r\n\r\n    for (let i = 0; i < N; i++){\r\n        //create random individual\r\n        Cpopulation.push(randomGrid(grid,mutable))\r\n    }\r\n\r\n    //Step 2: Selection\r\n    //Create reproductive population\r\n    let fitness = []\r\n    let Rpopulation = []\r\n    for (let i = 0; i < N; i++){\r\n        //evaluate error of each individual\r\n        //add individual to reproductive population according to its error\r\n        fitness.push(216-error(Cpopulation[i])-100) //Maximum error is 81*3-9*3 = 216. fitnesses never go below 100 so this -100 makes good fitness more significant\r\n        for (let j=0; j<fitness[i]; j++){\r\n            Rpopulation.push(i)\r\n        }\r\n    }\r\n\r\n    //Step 3: Reproduction\r\n    //create new population from current reproductive population\r\n    let parent1 = -1\r\n    let parent2 = -1\r\n    for (let i = 0; i < N; i++){\r\n        //choose two random parents\r\n        parent1 = Rpopulation[getRandomInt(Rpopulation.length)+1]\r\n        parent2 = Rpopulation[getRandomInt(Rpopulation.length)+1]\r\n        while (parent2 === parent1) {\r\n            parent2 = getRandomInt(Rpopulation.length)+1\r\n        }\r\n        console.log(parent1,parent2)\r\n\r\n        //mix their info\r\n        // let Npopulation = []\r\n        // for (let i = 0; i < N; i ++) {\r\n\r\n        //     let tempGrid = [\r\n        //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        //         [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n        //         [0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n        //     ]\r\n\r\n        //     for (let row = 0; row < 9; row++) {\r\n        //         for (let col= 0; col< 9; col++){\r\n        //             if (mutable[row][col]) {\r\n        //                 if (Math.random > 0.5) {\r\n        //                     tempGrid[row][col] = Cpopulation[parent1][row][col]\r\n        //                 }\r\n        //                else {\r\n        //                    tempGrid[row][col] = Cpopulation[parent2][row][col]\r\n        //                } \r\n        //             }\r\n        //         }\r\n        //     }\r\n        //     Npopulation.push(tempGrid)\r\n        // }\r\n        // moves=Npopulation\r\n\r\n        //mutate\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default function geneticAlgorithm (grid) {\r\n    let mutable = []\r\n\r\n    //Prevents the algorithm from changing original node values\r\n    for (let row = 0; row < 9; row ++) {\r\n        let temp = []\r\n        for (let col = 0; col < 9; col ++){\r\n            if (grid[row][col] === 0 || grid[row][col] === '0') {\r\n                temp.push(true)\r\n            }\r\n            else{\r\n                temp.push(false)\r\n            }\r\n        }\r\n        mutable.push(temp)\r\n    }\r\n\r\n    //a list of the moves the algorithm will take\r\n    let moves = []\r\n\r\n    solve(grid,moves, mutable)\r\n\r\n    return moves\r\n}"]},"metadata":{},"sourceType":"module"}