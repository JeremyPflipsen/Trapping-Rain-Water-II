{"ast":null,"code":"function Node(row, col) {\n  return document.getElementById(`node-${row}-${col}`);\n} // Gets a node from the screen\n//this function is bound to App\n//so that it can call the functions in App\n\n\n_c = Node;\nexport default function stepBackward() {\n  //copy funtions from app so they can be called within helper\n  let setCurrIndex = this.setCurrIndex;\n  let currIndex = this.state.currIndex;\n  let moves = this.state.moves;\n\n  if (currIndex < 2) {\n    //no previous move so return\n    //no need to set moves or solvable since play or stepForward will do that in the first step\n    // console.log(\"no previous move\")\n    return;\n  } else if (currIndex === 2) {\n    //Only first step is done so undo first step\n    //make initial border\n    let tempMoves = moves[0].currMoves;\n\n    for (let i = 0; i < tempMoves.length; i++) {\n      Node(tempMoves[i][0], tempMoves[i][1]).className = \"node\";\n    } //color corners\n\n\n    tempMoves = moves[1].currMoves;\n\n    for (let i = 0; i < tempMoves.length; i++) {\n      Node(tempMoves[i][0], tempMoves[i][1]).className = \"node\";\n    } //set About color\n\n\n    document.getElementById(\"step1\").style.background = \"rgba(255, 0, 43, 0)\"; //we finished step 0, so currIndex = 2 now\n\n    currIndex = 0;\n    this.setState({\n      currIndex: currIndex\n    });\n  } else {\n    //no more special cases\n    //set color of steps\n    //FIXME complete\n    //check the currStep\n    let move, prevMove;\n\n    if (moves[currIndex - 1].currStep === 1) {\n      //highlight lowest border node\n      move = moves[currIndex - 1].currMoves[0];\n      Node(move[0], move[1]).className = \"node-finish\";\n    } else if (moves[currIndex - 1].currStep === 2) {\n      //add new border node\n      move = moves[currIndex - 1].currMoves[0];\n      Node(move[0], move[1]).className = \"node\";\n    } else if (moves[currIndex - 1].currStep === 3) {\n      //add highlighting of lowest border node\n      prevMove = moves[currIndex - 1].currMoves[0];\n      Node(prevMove[0], prevMove[1]).className = \"node-start\"; //add removed border nodes\n\n      for (let i = 0; i < moves[currIndex - 1].currMoves.length; i++) {\n        //remove border node\n        move = moves[currIndex - 1].currMoves[i];\n        Node(move[0], move[1]).className = \"node-finish\";\n      }\n    }\n\n    currIndex -= 1;\n    setCurrIndex(currIndex);\n  }\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"Node\");","map":{"version":3,"sources":["C:/Users/hp/Desktop/Trapping_Water/my-app/src/stepBackward.js"],"names":["Node","row","col","document","getElementById","stepBackward","setCurrIndex","currIndex","state","moves","tempMoves","currMoves","i","length","className","style","background","setState","move","prevMove","currStep"],"mappings":"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","sourcesContent":["function Node(row, col) {\r\n  return document.getElementById(`node-${row}-${col}`)\r\n} // Gets a node from the screen\r\n\r\n//this function is bound to App\r\n//so that it can call the functions in App\r\n\r\nexport default function stepBackward() {\r\n  //copy funtions from app so they can be called within helper\r\n  let setCurrIndex = this.setCurrIndex\r\n  let currIndex = this.state.currIndex\r\n  let moves = this.state.moves\r\n\r\n  if (currIndex < 2) {\r\n    //no previous move so return\r\n    //no need to set moves or solvable since play or stepForward will do that in the first step\r\n    // console.log(\"no previous move\")\r\n    return\r\n  } else if (currIndex === 2) {\r\n    //Only first step is done so undo first step\r\n    //make initial border\r\n    let tempMoves = moves[0].currMoves\r\n    for (let i = 0; i < tempMoves.length; i++) {\r\n      Node(tempMoves[i][0], tempMoves[i][1]).className = \"node\"\r\n    }\r\n    //color corners\r\n    tempMoves = moves[1].currMoves\r\n    for (let i = 0; i < tempMoves.length; i++) {\r\n      Node(tempMoves[i][0], tempMoves[i][1]).className = \"node\"\r\n    }\r\n\r\n    //set About color\r\n    document.getElementById(\"step1\").style.background = \"rgba(255, 0, 43, 0)\"\r\n\r\n    //we finished step 0, so currIndex = 2 now\r\n    currIndex = 0\r\n    this.setState({ currIndex: currIndex })\r\n  } else {\r\n    //no more special cases\r\n\r\n    //set color of steps\r\n    //FIXME complete\r\n\r\n    //check the currStep\r\n    let move, prevMove\r\n    if (moves[currIndex - 1].currStep === 1) {\r\n      //highlight lowest border node\r\n      move = moves[currIndex - 1].currMoves[0]\r\n      Node(move[0], move[1]).className = \"node-finish\"\r\n    } else if (moves[currIndex - 1].currStep === 2) {\r\n      //add new border node\r\n      move = moves[currIndex - 1].currMoves[0]\r\n      Node(move[0], move[1]).className = \"node\"\r\n    } else if (moves[currIndex - 1].currStep === 3) {\r\n      //add highlighting of lowest border node\r\n      prevMove = moves[currIndex - 1].currMoves[0]\r\n      Node(prevMove[0], prevMove[1]).className = \"node-start\"\r\n\r\n      //add removed border nodes\r\n      for (let i = 0; i < moves[currIndex - 1].currMoves.length; i++) {\r\n        //remove border node\r\n        move = moves[currIndex - 1].currMoves[i]\r\n        Node(move[0], move[1]).className = \"node-finish\"\r\n      }\r\n    }\r\n\r\n    currIndex -= 1\r\n    setCurrIndex(currIndex)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}