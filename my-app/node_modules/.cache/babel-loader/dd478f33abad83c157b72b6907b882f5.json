{"ast":null,"code":"import initialAlg from \"./algorithms/initialAlg\";\n\nfunction Node(row, col) {\n  return document.getElementById(`node-${row}-${col}`);\n} // Gets a node from the screen\n//this function is bound to App\n//so that it can call the functions in App\n\n\n_c = Node;\nexport default function visualizeInitialAlg(moves, solvable) {\n  //check if moves has already been calculated\n  if (this.state.moves.length < 1) {\n    let temp = initialAlg(this.state.grid);\n    this.setState({\n      moves: temp.moves\n    });\n  } //copy funtions from app so they can be called within helper\n\n\n  let setCurrIndex = this.setCurrIndex;\n  let getMode = this.getMode; //Check if matrix is too small\n\n  if (!solvable) {\n    console.log(\"matrix too small\");\n    document.getElementById(\"Error\").innerHTML = \"Matrix has no inner tiles. Total Water = 0.\";\n    return;\n  }\n\n  let currIndex = this.state.currIndex; //how far we are along moves\n\n  console.log(\"In visualizeInitialAlg\", currIndex); //reset className of <div id=\"end\"><div> if it's still highlighted fromprevious run\n\n  document.getElementById(\"end\").className = \"\";\n\n  if (currIndex < 1) {\n    //make initial border\n    let tempMoves = moves[0].currMoves;\n\n    for (let i = 0; i < tempMoves.length; i++) {\n      Node(tempMoves[i][0], tempMoves[i][1]).className = \"node-finish\";\n    } //color corners\n\n\n    tempMoves = moves[1].currMoves;\n\n    for (let i = 0; i < tempMoves.length; i++) {\n      Node(tempMoves[i][0], tempMoves[i][1]).className = \"node-visited\";\n    } //set About color\n\n\n    document.getElementById(\"step1\").style.background = \"rgba(255, 0, 43, 0.3)\"; //we finished step 0, so currIndex = 2 now\n\n    currIndex = 2;\n    setCurrIndex(2);\n  } else {\n    helper(moves.slice(currIndex));\n    return;\n  } //show rest of moves\n\n\n  function helper(restMoves) {}\n\n  if (restMoves.length < 1) {\n    document.getElementById(\"end\").className = \"currStep\";\n    return currIndex;\n  } //set About color for current step\n\n\n  document.getElementById(`step${restMoves[0].currStep + 1}`).style.background = \"rgba(255, 0, 43, 0.3)\"; //reset About color from previous step\n\n  document.getElementById(`step${moves[currIndex - 1].currStep + 1}`).style.background = \"rgba(0, 0, 0, 0)\"; //set background opacity of last item to 0 to remove highlighting.\n  //update total and waterLevel on screen\n\n  document.getElementById(\"Error\").innerHTML = `Total Water: ${restMoves[0].total} \\n Water Level: ${restMoves[0].waterLevel}`;\n  let move;\n  let prevMove;\n\n  if (restMoves[0].currStep === 1) {\n    //highlight lowest border node\n    move = restMoves[0].currMoves[0];\n    Node(move[0], move[1]).className = \"node-start\";\n  } else if (restMoves[0].currStep === 2) {\n    //add new border node\n    move = restMoves[0].currMoves[0];\n    Node(move[0], move[1]).className = \"node-finish\";\n  } else if (restMoves[0].currStep === 3) {\n    //remove highlighting of lowest border node from step 1\n    prevMove = moves[currIndex - 2].currMoves[0];\n    Node(prevMove[0], prevMove[1]).className = \"node-finish\";\n\n    for (let i = 0; i < restMoves[0].currMoves.length; i++) {\n      //remove border node\n      move = restMoves[0].currMoves[i];\n      Node(move[0], move[1]).className = \"node-visited\";\n    }\n  } //we finished another step so increment currIndex\n\n\n  currIndex += 1;\n  setCurrIndex(currIndex);\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"Node\");","map":{"version":3,"sources":["C:/Users/hp/Desktop/Trapping_Water/my-app/src/stepForward.js"],"names":["initialAlg","Node","row","col","document","getElementById","visualizeInitialAlg","moves","solvable","state","length","temp","grid","setState","setCurrIndex","getMode","console","log","innerHTML","currIndex","className","tempMoves","currMoves","i","style","background","helper","slice","restMoves","currStep","total","waterLevel","move","prevMove"],"mappings":"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","sourcesContent":["import initialAlg from \"./algorithms/initialAlg\"\r\n\r\nfunction Node(row, col) {\r\n  return document.getElementById(`node-${row}-${col}`)\r\n} // Gets a node from the screen\r\n\r\n//this function is bound to App\r\n//so that it can call the functions in App\r\n\r\nexport default function visualizeInitialAlg(moves, solvable) {\r\n  //check if moves has already been calculated\r\n  if (this.state.moves.length < 1) {\r\n    let temp = initialAlg(this.state.grid)\r\n    this.setState({ moves: temp.moves })\r\n  }\r\n\r\n  //copy funtions from app so they can be called within helper\r\n  let setCurrIndex = this.setCurrIndex\r\n  let getMode = this.getMode\r\n\r\n  //Check if matrix is too small\r\n  if (!solvable) {\r\n    console.log(\"matrix too small\")\r\n    document.getElementById(\"Error\").innerHTML =\r\n      \"Matrix has no inner tiles. Total Water = 0.\"\r\n    return\r\n  }\r\n\r\n  let currIndex = this.state.currIndex //how far we are along moves\r\n  console.log(\"In visualizeInitialAlg\", currIndex)\r\n\r\n  //reset className of <div id=\"end\"><div> if it's still highlighted fromprevious run\r\n  document.getElementById(\"end\").className = \"\"\r\n\r\n  if (currIndex < 1) {\r\n    //make initial border\r\n    let tempMoves = moves[0].currMoves\r\n    for (let i = 0; i < tempMoves.length; i++) {\r\n      Node(tempMoves[i][0], tempMoves[i][1]).className = \"node-finish\"\r\n    }\r\n    //color corners\r\n    tempMoves = moves[1].currMoves\r\n    for (let i = 0; i < tempMoves.length; i++) {\r\n      Node(tempMoves[i][0], tempMoves[i][1]).className = \"node-visited\"\r\n    }\r\n\r\n    //set About color\r\n    document.getElementById(\"step1\").style.background = \"rgba(255, 0, 43, 0.3)\"\r\n\r\n    //we finished step 0, so currIndex = 2 now\r\n    currIndex = 2\r\n    setCurrIndex(2)\r\n  } else {\r\n    helper(moves.slice(currIndex))\r\n    return\r\n  }\r\n\r\n  //show rest of moves\r\n  function helper(restMoves) {}\r\n  if (restMoves.length < 1) {\r\n    document.getElementById(\"end\").className = \"currStep\"\r\n    return currIndex\r\n  }\r\n\r\n  //set About color for current step\r\n  document.getElementById(`step${restMoves[0].currStep + 1}`).style.background =\r\n    \"rgba(255, 0, 43, 0.3)\"\r\n  //reset About color from previous step\r\n  document.getElementById(\r\n    `step${moves[currIndex - 1].currStep + 1}`\r\n  ).style.background = \"rgba(0, 0, 0, 0)\" //set background opacity of last item to 0 to remove highlighting.\r\n\r\n  //update total and waterLevel on screen\r\n  document.getElementById(\r\n    \"Error\"\r\n  ).innerHTML = `Total Water: ${restMoves[0].total} \\n Water Level: ${restMoves[0].waterLevel}`\r\n\r\n  let move\r\n  let prevMove\r\n  if (restMoves[0].currStep === 1) {\r\n    //highlight lowest border node\r\n    move = restMoves[0].currMoves[0]\r\n    Node(move[0], move[1]).className = \"node-start\"\r\n  } else if (restMoves[0].currStep === 2) {\r\n    //add new border node\r\n    move = restMoves[0].currMoves[0]\r\n    Node(move[0], move[1]).className = \"node-finish\"\r\n  } else if (restMoves[0].currStep === 3) {\r\n    //remove highlighting of lowest border node from step 1\r\n    prevMove = moves[currIndex - 2].currMoves[0]\r\n    Node(prevMove[0], prevMove[1]).className = \"node-finish\"\r\n\r\n    for (let i = 0; i < restMoves[0].currMoves.length; i++) {\r\n      //remove border node\r\n      move = restMoves[0].currMoves[i]\r\n      Node(move[0], move[1]).className = \"node-visited\"\r\n    }\r\n  }\r\n\r\n  //we finished another step so increment currIndex\r\n  currIndex += 1\r\n  setCurrIndex(currIndex)\r\n}\r\n"]},"metadata":{},"sourceType":"module"}