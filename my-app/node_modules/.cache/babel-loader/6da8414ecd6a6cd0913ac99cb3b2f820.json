{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\hp\\\\Desktop\\\\Sudoku\\\\my-app\\\\src\\\\About.js\";\nimport React, { Component } from \"react\";\nimport './About.css';\nexport default class About extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.chooseAbout = this.chooseAbout.bind(this);\n  }\n\n  chooseAbout(alg) {\n    switch (alg) {\n      case 1:\n        return `Backtracking is essentially structured guessing until you find \n                    a solution that works. In this algorithm, we start at the top\n                    left corner square. We choose the lowest number, 1 through 9, that\n                    doesn't conflict with row, columnn, or 3x3 square of the current square.\n                     Then we move on to the next square and do the same. We keep \n                    doing this until we reach a square where none of the numbers \n                    1-9 work. Then we back up to the previous square. If no numbers\n                    work in that square, then we back up again, and again, and so on\n                    until we find a square where a new value works. Then we move on\n                    to the next square from there and restart the whole process.\n                    `;\n\n      case 2:\n        return `Hill Climbing is an example of a greedy algorithm, meaning that\n                    at each step in the algorithm, it chooses the option that maximizes\n                    its short-term gain to the next step. In this implementation, we\n                    define some amount of Error in the grid. The Error is the sum of\n                    all the duplicates in all of the rows and columns, and is shown on\n                    the right side of the screen. The algorithm starts by filling in the\n                    3x3 squares with all the numbers 1-9, so that there are no\n                    duplicates in the 3x3 squares and only duplicates in the rows and\n                    columns. Then the algorithm chooses two random 1x1 squares in a random\n                    3x3 square. If switching their values lowers the number of duplicates\n                    in the rows and columns of the grid, then the error is lower and\n                    the algorithm will make this switch. If this switch increases the\n                    number of errors in the board, then the algorithm will not make this\n                    switch. It looks at around 50000 moves, but quickly reaches a point\n                    where there aren't any moves that will lower the error, even though\n                    the grid is not solved. This is called a \"local minimum\" in the error,\n                    but it is not the \"absolute minimum\" of 0 error that we want.`;\n\n      case 3:\n        return \"Simulated Annealing\";\n\n      default:\n        return \"Choose an algorithm!\";\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"span\", {\n      className: \"About\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 62,\n        columnNumber: 9\n      }\n    }, this.chooseAbout(this.props.selectedAlg));\n  }\n\n}","map":{"version":3,"sources":["C:/Users/hp/Desktop/Sudoku/my-app/src/About.js"],"names":["React","Component","About","constructor","props","state","chooseAbout","bind","alg","render","selectedAlg"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAO,aAAP;AAEA,eAAe,MAAMC,KAAN,SAAoBD,SAApB,CAA6B;AACxCE,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAa,EAAb;AAEA,SAAKC,WAAL,GAAmB,KAAKA,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,CAAnB;AACD;;AAEHD,EAAAA,WAAW,CAACE,GAAD,EAAM;AACb,YAAQA,GAAR;AACI,WAAK,CAAL;AACI,eACK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAXgB;;AAcJ,WAAK,CAAL;AACI,eACK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAjBgB;;AAoBJ,WAAK,CAAL;AACI,eACI,qBADJ;;AAIJ;AACI,eAAO,sBAAP;AA3CR;AA6CH;;AAEDC,EAAAA,MAAM,GAAG;AACL,wBACA;AAAM,MAAA,SAAS,EAAC,OAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAyB,KAAKH,WAAL,CAAiB,KAAKF,KAAL,CAAWM,WAA5B,CAAzB,CADA;AAGH;;AA5DuC","sourcesContent":["import React, { Component } from \"react\";\r\nimport './About.css'\r\n\r\nexport default class About extends Component{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n        };\r\n        this.chooseAbout = this.chooseAbout.bind(this)\r\n      }\r\n\r\n    chooseAbout(alg) {\r\n        switch (alg) {\r\n            case 1:\r\n                return (\r\n                    `Backtracking is essentially structured guessing until you find \r\n                    a solution that works. In this algorithm, we start at the top\r\n                    left corner square. We choose the lowest number, 1 through 9, that\r\n                    doesn't conflict with row, columnn, or 3x3 square of the current square.\r\n                     Then we move on to the next square and do the same. We keep \r\n                    doing this until we reach a square where none of the numbers \r\n                    1-9 work. Then we back up to the previous square. If no numbers\r\n                    work in that square, then we back up again, and again, and so on\r\n                    until we find a square where a new value works. Then we move on\r\n                    to the next square from there and restart the whole process.\r\n                    `\r\n                    )\r\n            \r\n            case 2: \r\n                return (\r\n                    `Hill Climbing is an example of a greedy algorithm, meaning that\r\n                    at each step in the algorithm, it chooses the option that maximizes\r\n                    its short-term gain to the next step. In this implementation, we\r\n                    define some amount of Error in the grid. The Error is the sum of\r\n                    all the duplicates in all of the rows and columns, and is shown on\r\n                    the right side of the screen. The algorithm starts by filling in the\r\n                    3x3 squares with all the numbers 1-9, so that there are no\r\n                    duplicates in the 3x3 squares and only duplicates in the rows and\r\n                    columns. Then the algorithm chooses two random 1x1 squares in a random\r\n                    3x3 square. If switching their values lowers the number of duplicates\r\n                    in the rows and columns of the grid, then the error is lower and\r\n                    the algorithm will make this switch. If this switch increases the\r\n                    number of errors in the board, then the algorithm will not make this\r\n                    switch. It looks at around 50000 moves, but quickly reaches a point\r\n                    where there aren't any moves that will lower the error, even though\r\n                    the grid is not solved. This is called a \"local minimum\" in the error,\r\n                    but it is not the \"absolute minimum\" of 0 error that we want.`\r\n                )\r\n\r\n            case 3: \r\n                return (\r\n                    \"Simulated Annealing\"\r\n                )\r\n            \r\n            default:\r\n                return \"Choose an algorithm!\"\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n        <span className='About'>{this.chooseAbout(this.props.selectedAlg)}</span>\r\n        )\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}