{"ast":null,"code":"/**\r\n * @param {number[][]} heightMap\r\n * @return {number}\r\n */\nvar trapRainWater = function (heightMap, moves) {\n  let h = heightMap.length;\n  let w = heightMap[0].length;\n  let numZeros = (w - 2) * (h - 2); //number of tiles left to be traversed\n\n  let waterLevel = 0; //current water level within borders\n\n  let minHeight; //minimum height of border tiles\n\n  let currMoves = []; //check for too small of a matrix\n\n  if (h < 3 || w < 3) {\n    return 0;\n  }\n\n  let traversed = []; //record of tiles that have been traversed\n\n  for (var i = 0; i < h; i++) {\n    traversed[i] = [];\n\n    for (var j = 0; j < w; j++) {\n      traversed[i][j] = 0;\n    }\n  } //add outer tiles of heightMap as border\n\n\n  let borderCoords = []; //coordinates of border tiles. index is row, value is column.\n\n  for (let i = 0; i < h; i++) {\n    borderCoords[i] = [];\n  } //traverse all border tiles and corners\n  //top and bottom\n\n\n  for (let i = 1; i < w - 1; i++) {\n    borderCoords[0].push(i);\n    borderCoords[h - 1].push(i);\n    traversed[0][i] = 1;\n    traversed[h - 1][i] = 1; //add these to moves\n\n    currMoves.push([[0], [i]], [[h - 1], [i]]);\n  } //right and left sides\n\n\n  for (let j = 1; j < h - 1; j++) {\n    borderCoords[j].push(0);\n    borderCoords[j].push(w - 1);\n    traversed[j][0] = 1;\n    traversed[j][w - 1] = 1;\n    currMoves.push([[j], [0]], [[j], [w - 1]]);\n  } //corners\n\n\n  traversed[0][0] = 1;\n  traversed[0][w - 1] = 1;\n  traversed[h - 1][0] = 1;\n  traversed[h - 1][w - 1] = 1; //add initial moves to moves\n\n  moves.push({\n    currStep: 0,\n    currMoves: currMoves\n  });\n  currMoves = []; //total is the amount of water that can be held\n\n  let total = 0; //main loop\n\n  while (numZeros !== 0) {\n    //if new minHeight is more than old, add (newMinHeight - OldMinHeight)*numZerosY\n    for (let i = 0; i < borderCoords.length; i++) {\n      if (borderCoords[i].length > 0) {\n        minHeight = heightMap[i][borderCoords[i][0]];\n        break;\n      }\n    }\n\n    for (let i = 0; i < borderCoords.length; i++) {\n      for (let j = 0; j < borderCoords[i].length; j++) {\n        if (heightMap[i][borderCoords[i][j]] < minHeight) {\n          minHeight = heightMap[i][borderCoords[i][j]];\n        }\n      }\n    }\n\n    if (minHeight > waterLevel) {\n      total += (minHeight - waterLevel) * numZeros;\n      waterLevel = minHeight;\n    } //find lowest border tile\n\n\n    let mini, minj;\n\n    for (let i = 0; i < h; i++) {\n      for (let j = 0; j < borderCoords[i].length; j++) {\n        if (heightMap[i][borderCoords[i][j]] === minHeight) {\n          mini = i;\n          minj = borderCoords[i][j];\n          break;\n        }\n      }\n    } //get 0 tile next to lowest border tile\n\n\n    let nextTile = checkNeighbor(mini, minj, 0); //We have our new tile at lowestCoords\n    //update traversed\n\n    traversed[nextTile[0]][nextTile[1]] = 1; //update numZeros\n\n    numZeros -= 1; //remove rock of nextTile from total\n\n    if (heightMap[nextTile[0]][nextTile[1]] <= waterLevel) {\n      total -= heightMap[nextTile[0]][nextTile[1]];\n    } else {\n      total -= waterLevel;\n    } //add nextTile to border\n\n\n    borderCoords[nextTile[0]].push(nextTile[1]);\n    currMoves.push([nextTile[0], nextTile[1]]);\n    moves.push({\n      currStep: 1,\n      currMoves: currMoves\n    });\n    currMoves = []; //check neighbors of new border tile, if they're no longer next to a 0 tile, then remove them. also check nextTile\n    //above\n\n    let bordi = nextTile[0] - 1;\n    let bordj = nextTile[1];\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //below\n\n\n    bordi = nextTile[0] + 1;\n    bordj = nextTile[1];\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //left\n\n\n    bordi = nextTile[0];\n    bordj = nextTile[1] - 1;\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //right\n\n\n    bordi = nextTile[0];\n    bordj = nextTile[1] + 1;\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //nextTile\n\n\n    bordi = nextTile[0];\n    bordj = nextTile[1];\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //update moves with border tiles to remove\n\n\n    moves.push({\n      currStep: 2,\n      currMoves: currMoves\n    });\n    currMoves = [];\n  }\n\n  return moves; //checks neighbors of a tile for a certain value of traversed, returns the first neighbor's coordinates to satisfy\n\n  function checkNeighbor(i, j, value) {\n    //above\n    try {\n      if (traversed[i - 1][j] === value) {\n        return [i - 1, j];\n      }\n    } catch {//neighbor doesn't exist so do nothing. This happens at the edges of heightMap and traversed.\n    } //below\n\n\n    try {\n      if (traversed[i + 1][j] === value) {\n        return [i + 1, j];\n      }\n    } catch {//neighbor doesn't exist so do nothing\n    } //left\n\n\n    try {\n      if (traversed[i][j - 1] === value) {\n        return [i, j - 1];\n      }\n    } catch {//neighbor doesn't exist so do nothing\n    } //right\n\n\n    try {\n      if (traversed[i][j + 1] === value) {\n        return [i, j + 1];\n      }\n    } catch {//neighbor doesn't exist so do nothing\n    }\n\n    return [];\n  }\n};\n\nexport default function initialAlg(heightMap) {\n  let moves = [];\n  moves = trapRainWater(heightMap, moves); //   console.log(moves)\n\n  return {\n    moves: moves\n  };\n}","map":{"version":3,"sources":["C:/Users/hp/Desktop/Trapping_Water/my-app/src/algorithms/initialAlg.js"],"names":["trapRainWater","heightMap","moves","h","length","w","numZeros","waterLevel","minHeight","currMoves","traversed","i","j","borderCoords","push","currStep","total","mini","minj","nextTile","checkNeighbor","bordi","bordj","includes","indexToRemove","indexOf","splice","value","initialAlg"],"mappings":"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","sourcesContent":["/**\r\n * @param {number[][]} heightMap\r\n * @return {number}\r\n */\r\nvar trapRainWater = function (heightMap, moves) {\r\n  let h = heightMap.length\r\n  let w = heightMap[0].length\r\n  let numZeros = (w - 2) * (h - 2) //number of tiles left to be traversed\r\n  let waterLevel = 0 //current water level within borders\r\n  let minHeight //minimum height of border tiles\r\n  let currMoves = []\r\n\r\n  //check for too small of a matrix\r\n  if (h < 3 || w < 3) {\r\n    return 0\r\n  }\r\n\r\n  let traversed = [] //record of tiles that have been traversed\r\n  for (var i = 0; i < h; i++) {\r\n    traversed[i] = []\r\n    for (var j = 0; j < w; j++) {\r\n      traversed[i][j] = 0\r\n    }\r\n  }\r\n\r\n  //add outer tiles of heightMap as border\r\n  let borderCoords = [] //coordinates of border tiles. index is row, value is column.\r\n  for (let i = 0; i < h; i++) {\r\n    borderCoords[i] = []\r\n  }\r\n\r\n  //traverse all border tiles and corners\r\n  //top and bottom\r\n  for (let i = 1; i < w - 1; i++) {\r\n    borderCoords[0].push(i)\r\n    borderCoords[h - 1].push(i)\r\n    traversed[0][i] = 1\r\n    traversed[h - 1][i] = 1\r\n    //add these to moves\r\n    currMoves.push([[0], [i]], [[h - 1], [i]])\r\n  }\r\n  //right and left sides\r\n  for (let j = 1; j < h - 1; j++) {\r\n    borderCoords[j].push(0)\r\n    borderCoords[j].push(w - 1)\r\n    traversed[j][0] = 1\r\n    traversed[j][w - 1] = 1\r\n    currMoves.push([[j], [0]], [[j], [w - 1]])\r\n  }\r\n\r\n  //corners\r\n  traversed[0][0] = 1\r\n  traversed[0][w - 1] = 1\r\n  traversed[h - 1][0] = 1\r\n  traversed[h - 1][w - 1] = 1\r\n\r\n  //add initial moves to moves\r\n  moves.push({ currStep: 0, currMoves: currMoves })\r\n  currMoves = []\r\n\r\n  //total is the amount of water that can be held\r\n  let total = 0\r\n\r\n  //main loop\r\n  while (numZeros !== 0) {\r\n    //if new minHeight is more than old, add (newMinHeight - OldMinHeight)*numZerosY\r\n    for (let i = 0; i < borderCoords.length; i++) {\r\n      if (borderCoords[i].length > 0) {\r\n        minHeight = heightMap[i][borderCoords[i][0]]\r\n        break\r\n      }\r\n    }\r\n    for (let i = 0; i < borderCoords.length; i++) {\r\n      for (let j = 0; j < borderCoords[i].length; j++) {\r\n        if (heightMap[i][borderCoords[i][j]] < minHeight) {\r\n          minHeight = heightMap[i][borderCoords[i][j]]\r\n        }\r\n      }\r\n    }\r\n\r\n    if (minHeight > waterLevel) {\r\n      total += (minHeight - waterLevel) * numZeros\r\n      waterLevel = minHeight\r\n    }\r\n\r\n    //find lowest border tile\r\n    let mini, minj\r\n    for (let i = 0; i < h; i++) {\r\n      for (let j = 0; j < borderCoords[i].length; j++) {\r\n        if (heightMap[i][borderCoords[i][j]] === minHeight) {\r\n          mini = i\r\n          minj = borderCoords[i][j]\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    //get 0 tile next to lowest border tile\r\n    let nextTile = checkNeighbor(mini, minj, 0)\r\n\r\n    //We have our new tile at lowestCoords\r\n    //update traversed\r\n    traversed[nextTile[0]][nextTile[1]] = 1\r\n    //update numZeros\r\n    numZeros -= 1\r\n    //remove rock of nextTile from total\r\n    if (heightMap[nextTile[0]][nextTile[1]] <= waterLevel) {\r\n      total -= heightMap[nextTile[0]][nextTile[1]]\r\n    } else {\r\n      total -= waterLevel\r\n    }\r\n    //add nextTile to border\r\n    borderCoords[nextTile[0]].push(nextTile[1])\r\n    currMoves.push([nextTile[0], nextTile[1]])\r\n    moves.push({ currStep: 1, currMoves: currMoves })\r\n    currMoves = []\r\n\r\n    //check neighbors of new border tile, if they're no longer next to a 0 tile, then remove them. also check nextTile\r\n    //above\r\n    let bordi = nextTile[0] - 1\r\n    let bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //below\r\n    bordi = nextTile[0] + 1\r\n    bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //left\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1] - 1\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //right\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1] + 1\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //nextTile\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //update moves with border tiles to remove\r\n    moves.push({ currStep: 2, currMoves: currMoves })\r\n    currMoves = []\r\n  }\r\n\r\n  return moves\r\n\r\n  //checks neighbors of a tile for a certain value of traversed, returns the first neighbor's coordinates to satisfy\r\n  function checkNeighbor(i, j, value) {\r\n    //above\r\n    try {\r\n      if (traversed[i - 1][j] === value) {\r\n        return [i - 1, j]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing. This happens at the edges of heightMap and traversed.\r\n    }\r\n    //below\r\n    try {\r\n      if (traversed[i + 1][j] === value) {\r\n        return [i + 1, j]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n    //left\r\n    try {\r\n      if (traversed[i][j - 1] === value) {\r\n        return [i, j - 1]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n\r\n    //right\r\n    try {\r\n      if (traversed[i][j + 1] === value) {\r\n        return [i, j + 1]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n\r\n    return []\r\n  }\r\n}\r\n\r\nexport default function initialAlg(heightMap) {\r\n  let moves = []\r\n\r\n  moves = trapRainWater(heightMap, moves)\r\n  //   console.log(moves)\r\n\r\n  return { moves: moves }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}