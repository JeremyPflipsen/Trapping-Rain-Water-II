{"ast":null,"code":"/**\r\n * @param {number[][]} heightMap\r\n * @return {number}\r\n */var trapRainWater=function trapRainWater(heightMap,moves){var h=heightMap.length;var w=heightMap[0].length;var numZeros=(w-2)*(h-2);//number of tiles left to be traversed\nvar waterLevel=0;//current water level within borders\nvar minHeight;//minimum height of border tiles\nvar currMoves=[];var total=0;//total is the amount of water that can be held\n//check for too small of a matrix\nif(h<3||w<3){return{moves:[],solvable:false};}var traversed=[];//record of tiles that have been traversed\nfor(var i=0;i<h;i++){traversed[i]=[];for(var j=0;j<w;j++){traversed[i][j]=0;}}//add outer tiles of heightMap as border\nvar borderCoords=[];//coordinates of border tiles. index is row, value is column.\nfor(var _i=0;_i<h;_i++){borderCoords[_i]=[];}//traverse all border tiles and corners\n//top and bottom\nfor(var _i2=1;_i2<w-1;_i2++){borderCoords[0].push(_i2);borderCoords[h-1].push(_i2);traversed[0][_i2]=1;traversed[h-1][_i2]=1;//add these to moves\ncurrMoves.push([[0],[_i2]],[[h-1],[_i2]]);}//right and left sides\nfor(var _j=1;_j<h-1;_j++){borderCoords[_j].push(0);borderCoords[_j].push(w-1);traversed[_j][0]=1;traversed[_j][w-1]=1;currMoves.push([[_j],[0]],[[_j],[w-1]]);}//add initial border to moves\nmoves.push({currStep:0,currMoves:currMoves,total:total,waterLevel:waterLevel});currMoves=[];//corners\ntraversed[0][0]=1;traversed[0][w-1]=1;traversed[h-1][0]=1;traversed[h-1][w-1]=1;currMoves.push([[0],[0]],[[0],[w-1]],[[h-1],[0]],[[h-1],[w-1]]);moves.push({currStep:0,currMoves:currMoves,total:total,waterLevel:waterLevel});currMoves=[];//main loop\nwhile(numZeros!==0){//if new minHeight is more than old, add (newMinHeight - OldMinHeight)*numZerosY\nfor(var _i3=0;_i3<borderCoords.length;_i3++){if(borderCoords[_i3].length>0){minHeight=heightMap[_i3][borderCoords[_i3][0]];break;}}for(var _i4=0;_i4<borderCoords.length;_i4++){for(var _j2=0;_j2<borderCoords[_i4].length;_j2++){if(heightMap[_i4][borderCoords[_i4][_j2]]<minHeight){minHeight=heightMap[_i4][borderCoords[_i4][_j2]];}}}if(minHeight>waterLevel){total+=(minHeight-waterLevel)*numZeros;waterLevel=minHeight;}//find lowest border tile\nvar mini=void 0,minj=void 0;for(var _i5=0;_i5<h;_i5++){for(var _j3=0;_j3<borderCoords[_i5].length;_j3++){if(heightMap[_i5][borderCoords[_i5][_j3]]===minHeight){mini=_i5;minj=borderCoords[_i5][_j3];break;}}}//add lowest border node to moves\ncurrMoves.push([mini,minj]);moves.push({currStep:1,currMoves:currMoves,total:total,waterLevel:waterLevel});currMoves=[];//get 0 tile next to lowest border tile\nvar nextTile=checkNeighbor(mini,minj,0);//We have our new tile at lowestCoords\n//update traversed\ntraversed[nextTile[0]][nextTile[1]]=1;//update numZeros\nnumZeros-=1;//remove rock of nextTile from total\nif(heightMap[nextTile[0]][nextTile[1]]<=waterLevel){total-=heightMap[nextTile[0]][nextTile[1]];}else{total-=waterLevel;}//add nextTile to border\nborderCoords[nextTile[0]].push(nextTile[1]);currMoves.push([nextTile[0],nextTile[1]]);moves.push({currStep:2,currMoves:currMoves,total:total,waterLevel:waterLevel});currMoves=[];//check neighbors of new border tile, if they're no longer next to a 0 tile, then remove them. also check nextTile\n//above\nvar bordi=nextTile[0]-1;var bordj=nextTile[1];if(borderCoords[bordi].includes(bordj)){if(checkNeighbor(bordi,bordj,0).length===0){var indexToRemove=borderCoords[bordi].indexOf(bordj);borderCoords[bordi].splice(indexToRemove,1);currMoves.push([bordi,bordj]);}}//below\nbordi=nextTile[0]+1;bordj=nextTile[1];if(borderCoords[bordi].includes(bordj)){if(checkNeighbor(bordi,bordj,0).length===0){var _indexToRemove=borderCoords[bordi].indexOf(bordj);borderCoords[bordi].splice(_indexToRemove,1);currMoves.push([bordi,bordj]);}}//left\nbordi=nextTile[0];bordj=nextTile[1]-1;if(borderCoords[bordi].includes(bordj)){if(checkNeighbor(bordi,bordj,0).length===0){var _indexToRemove2=borderCoords[bordi].indexOf(bordj);borderCoords[bordi].splice(_indexToRemove2,1);currMoves.push([bordi,bordj]);}}//right\nbordi=nextTile[0];bordj=nextTile[1]+1;if(borderCoords[bordi].includes(bordj)){if(checkNeighbor(bordi,bordj,0).length===0){var _indexToRemove3=borderCoords[bordi].indexOf(bordj);borderCoords[bordi].splice(_indexToRemove3,1);currMoves.push([bordi,bordj]);}}//nextTile\nbordi=nextTile[0];bordj=nextTile[1];if(borderCoords[bordi].includes(bordj)){if(checkNeighbor(bordi,bordj,0).length===0){var _indexToRemove4=borderCoords[bordi].indexOf(bordj);borderCoords[bordi].splice(_indexToRemove4,1);currMoves.push([bordi,bordj]);}}//update moves with border tiles to remove\nmoves.push({currStep:3,currMoves:currMoves,total:total,waterLevel:waterLevel});currMoves=[];}return{moves:moves,solvable:true};//checks neighbors of a tile for a certain value of traversed, returns the first neighbor's coordinates to satisfy\nfunction checkNeighbor(i,j,value){//above\ntry{if(traversed[i-1][j]===value){return[i-1,j];}}catch(_unused){//neighbor doesn't exist so do nothing. This happens at the edges of heightMap and traversed.\n}//below\ntry{if(traversed[i+1][j]===value){return[i+1,j];}}catch(_unused2){//neighbor doesn't exist so do nothing\n}//left\ntry{if(traversed[i][j-1]===value){return[i,j-1];}}catch(_unused3){//neighbor doesn't exist so do nothing\n}//right\ntry{if(traversed[i][j+1]===value){return[i,j+1];}}catch(_unused4){//neighbor doesn't exist so do nothing\n}return[];}};export default function initialAlg(heightMap){var _trapRainWater=trapRainWater(heightMap,[]),moves=_trapRainWater.moves,solvable=_trapRainWater.solvable;return{moves:moves,solvable:solvable};}","map":{"version":3,"sources":["C:/Users/hp/Desktop/Trapping-Rain-Water-II/my-app/src/algorithms/initialAlg.js"],"names":["trapRainWater","heightMap","moves","h","length","w","numZeros","waterLevel","minHeight","currMoves","total","solvable","traversed","i","j","borderCoords","push","currStep","mini","minj","nextTile","checkNeighbor","bordi","bordj","includes","indexToRemove","indexOf","splice","value","initialAlg"],"mappings":"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","sourcesContent":["/**\r\n * @param {number[][]} heightMap\r\n * @return {number}\r\n */\r\nvar trapRainWater = function (heightMap, moves) {\r\n  let h = heightMap.length\r\n  let w = heightMap[0].length\r\n  let numZeros = (w - 2) * (h - 2) //number of tiles left to be traversed\r\n  let waterLevel = 0 //current water level within borders\r\n  let minHeight //minimum height of border tiles\r\n  let currMoves = []\r\n  let total = 0 //total is the amount of water that can be held\r\n\r\n  //check for too small of a matrix\r\n  if (h < 3 || w < 3) {\r\n    return { moves: [], solvable: false }\r\n  }\r\n\r\n  let traversed = [] //record of tiles that have been traversed\r\n  for (var i = 0; i < h; i++) {\r\n    traversed[i] = []\r\n    for (var j = 0; j < w; j++) {\r\n      traversed[i][j] = 0\r\n    }\r\n  }\r\n\r\n  //add outer tiles of heightMap as border\r\n  let borderCoords = [] //coordinates of border tiles. index is row, value is column.\r\n  for (let i = 0; i < h; i++) {\r\n    borderCoords[i] = []\r\n  }\r\n\r\n  //traverse all border tiles and corners\r\n  //top and bottom\r\n  for (let i = 1; i < w - 1; i++) {\r\n    borderCoords[0].push(i)\r\n    borderCoords[h - 1].push(i)\r\n    traversed[0][i] = 1\r\n    traversed[h - 1][i] = 1\r\n    //add these to moves\r\n    currMoves.push([[0], [i]], [[h - 1], [i]])\r\n  }\r\n  //right and left sides\r\n  for (let j = 1; j < h - 1; j++) {\r\n    borderCoords[j].push(0)\r\n    borderCoords[j].push(w - 1)\r\n    traversed[j][0] = 1\r\n    traversed[j][w - 1] = 1\r\n    currMoves.push([[j], [0]], [[j], [w - 1]])\r\n  }\r\n  //add initial border to moves\r\n  moves.push({\r\n    currStep: 0,\r\n    currMoves: currMoves,\r\n    total: total,\r\n    waterLevel: waterLevel,\r\n  })\r\n  currMoves = []\r\n\r\n  //corners\r\n  traversed[0][0] = 1\r\n  traversed[0][w - 1] = 1\r\n  traversed[h - 1][0] = 1\r\n  traversed[h - 1][w - 1] = 1\r\n  currMoves.push([[0], [0]], [[0], [w - 1]], [[h - 1], [0]], [[h - 1], [w - 1]])\r\n  moves.push({\r\n    currStep: 0,\r\n    currMoves: currMoves,\r\n    total: total,\r\n    waterLevel: waterLevel,\r\n  })\r\n  currMoves = []\r\n\r\n  //main loop\r\n  while (numZeros !== 0) {\r\n    //if new minHeight is more than old, add (newMinHeight - OldMinHeight)*numZerosY\r\n    for (let i = 0; i < borderCoords.length; i++) {\r\n      if (borderCoords[i].length > 0) {\r\n        minHeight = heightMap[i][borderCoords[i][0]]\r\n        break\r\n      }\r\n    }\r\n    for (let i = 0; i < borderCoords.length; i++) {\r\n      for (let j = 0; j < borderCoords[i].length; j++) {\r\n        if (heightMap[i][borderCoords[i][j]] < minHeight) {\r\n          minHeight = heightMap[i][borderCoords[i][j]]\r\n        }\r\n      }\r\n    }\r\n\r\n    if (minHeight > waterLevel) {\r\n      total += (minHeight - waterLevel) * numZeros\r\n      waterLevel = minHeight\r\n    }\r\n\r\n    //find lowest border tile\r\n    let mini, minj\r\n    for (let i = 0; i < h; i++) {\r\n      for (let j = 0; j < borderCoords[i].length; j++) {\r\n        if (heightMap[i][borderCoords[i][j]] === minHeight) {\r\n          mini = i\r\n          minj = borderCoords[i][j]\r\n          break\r\n        }\r\n      }\r\n    }\r\n    //add lowest border node to moves\r\n    currMoves.push([mini, minj])\r\n    moves.push({\r\n      currStep: 1,\r\n      currMoves: currMoves,\r\n      total: total,\r\n      waterLevel: waterLevel,\r\n    })\r\n    currMoves = []\r\n\r\n    //get 0 tile next to lowest border tile\r\n    let nextTile = checkNeighbor(mini, minj, 0)\r\n\r\n    //We have our new tile at lowestCoords\r\n    //update traversed\r\n    traversed[nextTile[0]][nextTile[1]] = 1\r\n    //update numZeros\r\n    numZeros -= 1\r\n    //remove rock of nextTile from total\r\n    if (heightMap[nextTile[0]][nextTile[1]] <= waterLevel) {\r\n      total -= heightMap[nextTile[0]][nextTile[1]]\r\n    } else {\r\n      total -= waterLevel\r\n    }\r\n    //add nextTile to border\r\n    borderCoords[nextTile[0]].push(nextTile[1])\r\n    currMoves.push([nextTile[0], nextTile[1]])\r\n    moves.push({\r\n      currStep: 2,\r\n      currMoves: currMoves,\r\n      total: total,\r\n      waterLevel: waterLevel,\r\n    })\r\n    currMoves = []\r\n\r\n    //check neighbors of new border tile, if they're no longer next to a 0 tile, then remove them. also check nextTile\r\n    //above\r\n    let bordi = nextTile[0] - 1\r\n    let bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //below\r\n    bordi = nextTile[0] + 1\r\n    bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //left\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1] - 1\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //right\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1] + 1\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //nextTile\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //update moves with border tiles to remove\r\n    moves.push({\r\n      currStep: 3,\r\n      currMoves: currMoves,\r\n      total: total,\r\n      waterLevel: waterLevel,\r\n    })\r\n    currMoves = []\r\n  }\r\n\r\n  return { moves: moves, solvable: true }\r\n\r\n  //checks neighbors of a tile for a certain value of traversed, returns the first neighbor's coordinates to satisfy\r\n  function checkNeighbor(i, j, value) {\r\n    //above\r\n    try {\r\n      if (traversed[i - 1][j] === value) {\r\n        return [i - 1, j]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing. This happens at the edges of heightMap and traversed.\r\n    }\r\n    //below\r\n    try {\r\n      if (traversed[i + 1][j] === value) {\r\n        return [i + 1, j]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n    //left\r\n    try {\r\n      if (traversed[i][j - 1] === value) {\r\n        return [i, j - 1]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n\r\n    //right\r\n    try {\r\n      if (traversed[i][j + 1] === value) {\r\n        return [i, j + 1]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n\r\n    return []\r\n  }\r\n}\r\n\r\nexport default function initialAlg(heightMap) {\r\n  let { moves, solvable } = trapRainWater(heightMap, [])\r\n\r\n  return { moves: moves, solvable: solvable }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}