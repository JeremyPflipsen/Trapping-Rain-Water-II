{"ast":null,"code":"/**\r\n * @param {number[][]} heightMap\r\n * @return {number}\r\n */\nvar trapRainWater = function (heightMap) {\n  let h = heightMap.length;\n  let w = heightMap[0].length;\n  let numZeros = (w - 2) * (h - 2); //number of tiles left to be traversed\n\n  let waterLevel = 0; //current water level within borders\n\n  let minHeight; //minimum height of border tiles\n  //check for too small of a matrix\n\n  if (h < 3 || w < 3) {\n    return 0;\n  }\n\n  let traversed = []; //record of tiles that have been traversed\n\n  for (var i = 0; i < h; i++) {\n    traversed[i] = [];\n\n    for (var j = 0; j < w; j++) {\n      traversed[i][j] = 0;\n    }\n  } //add outer tiles of heightMap as border\n\n\n  let borderCoords = []; //coordinates of border tiles. index is row, value is column.\n\n  for (let i = 0; i < h; i++) {\n    borderCoords[i] = [];\n  } //traverse all border tiles and corners\n  //top and bottom\n\n\n  for (let i = 1; i < w - 1; i++) {\n    // border[0][i] = 1\n    // border[h - 1][i] = 1\n    borderCoords[0].push(i);\n    borderCoords[h - 1].push(i);\n    traversed[0][i] = 1;\n    traversed[h - 1][i] = 1;\n  } //right and left sides\n\n\n  for (let j = 1; j < h - 1; j++) {\n    // border[j][0] = 1\n    // border[j][w-1] = 1\n    borderCoords[j].push(0);\n    borderCoords[j].push(w - 1);\n    traversed[j][0] = 1;\n    traversed[j][w - 1] = 1;\n  } //corners\n\n\n  traversed[0][0] = 1;\n  traversed[0][w - 1] = 1;\n  traversed[h - 1][0] = 1;\n  traversed[h - 1][w - 1] = 1; //total is the amount of water that can be held\n\n  let total = 0; //main loop\n\n  while (numZeros !== 0) {\n    //if new minHeight is more than old, add (newMinHeight - OldMinHeight)*numZerosY\n    for (let i = 0; i < borderCoords.length; i++) {\n      if (borderCoords[i].length > 0) {\n        minHeight = heightMap[i][borderCoords[i][0]];\n        break;\n      }\n    }\n\n    for (let i = 0; i < borderCoords.length; i++) {\n      for (let j = 0; j < borderCoords[i].length; j++) {\n        if (heightMap[i][borderCoords[i][j]] < minHeight) {\n          minHeight = heightMap[i][borderCoords[i][j]];\n        }\n      }\n    }\n\n    if (minHeight > waterLevel) {\n      total += (minHeight - waterLevel) * numZeros;\n      waterLevel = minHeight;\n    } //find lowest border tile\n\n\n    let mini, minj;\n\n    for (let i = 0; i < h; i++) {\n      for (let j = 0; j < borderCoords[i].length; j++) {\n        if (heightMap[i][borderCoords[i][j]] === minHeight) {\n          mini = i;\n          minj = borderCoords[i][j];\n          break;\n        }\n      }\n    } //get 0 tile next to lowest border tile\n\n\n    let nextTile = checkNeighbor(mini, minj, 0); //We have our new tile at lowestCoords\n    //update traversed\n\n    traversed[nextTile[0]][nextTile[1]] = 1; //update numZeros\n\n    numZeros -= 1; //remove rock of nextTile from total\n\n    if (heightMap[nextTile[0]][nextTile[1]] <= waterLevel) {\n      total -= heightMap[nextTile[0]][nextTile[1]];\n    } else {\n      total -= waterLevel;\n    } //add nextTile to border\n\n\n    borderCoords[nextTile[0]].push(nextTile[1]); //check neighbors of new border tile, if they're no longer next to a 0 tile, then remove them. also check nextTile\n    //above\n\n    let bordi = nextTile[0] - 1;\n    let bordj = nextTile[1];\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n      }\n    } //below\n\n\n    bordi = nextTile[0] + 1;\n    bordj = nextTile[1];\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n      }\n    } //left\n\n\n    bordi = nextTile[0];\n    bordj = nextTile[1] - 1;\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n      }\n    } //right\n\n\n    bordi = nextTile[0];\n    bordj = nextTile[1] + 1;\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n      }\n    } //nextTile\n\n\n    bordi = nextTile[0];\n    bordj = nextTile[1];\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n      }\n    }\n  }\n\n  return []; //checks neighbors of a tile for a certain value of traversed, returns the first neighbor's coordinates to satisfy\n\n  function checkNeighbor(i, j, value) {\n    //above\n    try {\n      if (traversed[i - 1][j] === value) {\n        return [i - 1, j];\n      }\n    } catch {//neighbor doesn't exist so do nothing. This happens at the edges of heightMap and traversed.\n    } //below\n\n\n    try {\n      if (traversed[i + 1][j] === value) {\n        return [i + 1, j];\n      }\n    } catch {//neighbor doesn't exist so do nothing\n    } //left\n\n\n    try {\n      if (traversed[i][j - 1] === value) {\n        return [i, j - 1];\n      }\n    } catch {//neighbor doesn't exist so do nothing\n    } //right\n\n\n    try {\n      if (traversed[i][j + 1] === value) {\n        return [i, j + 1];\n      }\n    } catch {//neighbor doesn't exist so do nothing\n    }\n\n    return [];\n  }\n};\n\nexport default function initialAlg(heightMap) {\n  let moves = [];\n  moves = trapRainWater(heightMap);\n  return moves;\n}","map":{"version":3,"sources":["C:/Users/hp/Desktop/Trapping_Water/my-app/src/algorithms/initialAlg.js"],"names":["trapRainWater","heightMap","h","length","w","numZeros","waterLevel","minHeight","traversed","i","j","borderCoords","push","total","mini","minj","nextTile","checkNeighbor","bordi","bordj","includes","indexToRemove","indexOf","splice","value","initialAlg","moves"],"mappings":"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","sourcesContent":["/**\r\n * @param {number[][]} heightMap\r\n * @return {number}\r\n */\r\nvar trapRainWater = function (heightMap) {\r\n  let h = heightMap.length\r\n  let w = heightMap[0].length\r\n  let numZeros = (w - 2) * (h - 2) //number of tiles left to be traversed\r\n  let waterLevel = 0 //current water level within borders\r\n  let minHeight //minimum height of border tiles\r\n\r\n  //check for too small of a matrix\r\n  if (h < 3 || w < 3) {\r\n    return 0\r\n  }\r\n\r\n  let traversed = [] //record of tiles that have been traversed\r\n  for (var i = 0; i < h; i++) {\r\n    traversed[i] = []\r\n    for (var j = 0; j < w; j++) {\r\n      traversed[i][j] = 0\r\n    }\r\n  }\r\n\r\n  //add outer tiles of heightMap as border\r\n  let borderCoords = [] //coordinates of border tiles. index is row, value is column.\r\n  for (let i = 0; i < h; i++) {\r\n    borderCoords[i] = []\r\n  }\r\n\r\n  //traverse all border tiles and corners\r\n  //top and bottom\r\n  for (let i = 1; i < w - 1; i++) {\r\n    // border[0][i] = 1\r\n    // border[h - 1][i] = 1\r\n    borderCoords[0].push(i)\r\n    borderCoords[h - 1].push(i)\r\n    traversed[0][i] = 1\r\n    traversed[h - 1][i] = 1\r\n  }\r\n  //right and left sides\r\n  for (let j = 1; j < h - 1; j++) {\r\n    // border[j][0] = 1\r\n    // border[j][w-1] = 1\r\n    borderCoords[j].push(0)\r\n    borderCoords[j].push(w - 1)\r\n    traversed[j][0] = 1\r\n    traversed[j][w - 1] = 1\r\n  }\r\n\r\n  //corners\r\n  traversed[0][0] = 1\r\n  traversed[0][w - 1] = 1\r\n  traversed[h - 1][0] = 1\r\n  traversed[h - 1][w - 1] = 1\r\n\r\n  //total is the amount of water that can be held\r\n  let total = 0\r\n\r\n  //main loop\r\n  while (numZeros !== 0) {\r\n    //if new minHeight is more than old, add (newMinHeight - OldMinHeight)*numZerosY\r\n    for (let i = 0; i < borderCoords.length; i++) {\r\n      if (borderCoords[i].length > 0) {\r\n        minHeight = heightMap[i][borderCoords[i][0]]\r\n        break\r\n      }\r\n    }\r\n    for (let i = 0; i < borderCoords.length; i++) {\r\n      for (let j = 0; j < borderCoords[i].length; j++) {\r\n        if (heightMap[i][borderCoords[i][j]] < minHeight) {\r\n          minHeight = heightMap[i][borderCoords[i][j]]\r\n        }\r\n      }\r\n    }\r\n\r\n    if (minHeight > waterLevel) {\r\n      total += (minHeight - waterLevel) * numZeros\r\n      waterLevel = minHeight\r\n    }\r\n\r\n    //find lowest border tile\r\n    let mini, minj\r\n    for (let i = 0; i < h; i++) {\r\n      for (let j = 0; j < borderCoords[i].length; j++) {\r\n        if (heightMap[i][borderCoords[i][j]] === minHeight) {\r\n          mini = i\r\n          minj = borderCoords[i][j]\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    //get 0 tile next to lowest border tile\r\n    let nextTile = checkNeighbor(mini, minj, 0)\r\n\r\n    //We have our new tile at lowestCoords\r\n    //update traversed\r\n    traversed[nextTile[0]][nextTile[1]] = 1\r\n    //update numZeros\r\n    numZeros -= 1\r\n    //remove rock of nextTile from total\r\n    if (heightMap[nextTile[0]][nextTile[1]] <= waterLevel) {\r\n      total -= heightMap[nextTile[0]][nextTile[1]]\r\n    } else {\r\n      total -= waterLevel\r\n    }\r\n    //add nextTile to border\r\n    borderCoords[nextTile[0]].push(nextTile[1])\r\n\r\n    //check neighbors of new border tile, if they're no longer next to a 0 tile, then remove them. also check nextTile\r\n    //above\r\n    let bordi = nextTile[0] - 1\r\n    let bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n      }\r\n    }\r\n    //below\r\n    bordi = nextTile[0] + 1\r\n    bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n      }\r\n    }\r\n    //left\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1] - 1\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n      }\r\n    }\r\n    //right\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1] + 1\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n      }\r\n    }\r\n    //nextTile\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n      }\r\n    }\r\n  }\r\n\r\n  return []\r\n\r\n  //checks neighbors of a tile for a certain value of traversed, returns the first neighbor's coordinates to satisfy\r\n  function checkNeighbor(i, j, value) {\r\n    //above\r\n    try {\r\n      if (traversed[i - 1][j] === value) {\r\n        return [i - 1, j]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing. This happens at the edges of heightMap and traversed.\r\n    }\r\n    //below\r\n    try {\r\n      if (traversed[i + 1][j] === value) {\r\n        return [i + 1, j]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n    //left\r\n    try {\r\n      if (traversed[i][j - 1] === value) {\r\n        return [i, j - 1]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n\r\n    //right\r\n    try {\r\n      if (traversed[i][j + 1] === value) {\r\n        return [i, j + 1]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n\r\n    return []\r\n  }\r\n}\r\n\r\nexport default function initialAlg(heightMap) {\r\n  let moves = []\r\n\r\n  moves = trapRainWater(heightMap)\r\n\r\n  return moves\r\n}\r\n"]},"metadata":{},"sourceType":"module"}