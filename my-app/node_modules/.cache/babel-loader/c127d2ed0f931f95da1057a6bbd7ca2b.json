{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\hp\\\\Desktop\\\\Trapping_Water\\\\my-app\\\\src\\\\About.js\";\nimport React, { Component } from \"react\";\nimport \"./About.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class About extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.chooseAbout = this.chooseAbout.bind(this);\n  }\n\n  chooseAbout(alg) {\n    switch (alg) {\n      case 1:\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [\"Backtracking is essentially structured guessing until you find a solution that works.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 18,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 19,\n            columnNumber: 13\n          }, this), \"Step 1: Choose 1x1 Square\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 21,\n            columnNumber: 13\n          }, this), \"Here we choose the top-left-most 1x1 square whose value is 0.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 23,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 24,\n            columnNumber: 13\n          }, this), \"Step 2: Choose Number\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 26,\n            columnNumber: 13\n          }, this), \"A conflict is when a the number in a 1x1 square already appears in the same row, column, or 3x3 square. Choose the lowest number 1-9 that doesn't cause a conflict and put it in the current chosen square. If all of the numbers 1-9 cause conflicts in the current square then go to step 3. Otherwise skip step 3 and go to step 4.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 32,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 33,\n            columnNumber: 13\n          }, this), \"Step 3: Backtrack\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 35,\n            columnNumber: 13\n          }, this), \"Back up to the previous chosen square. Chose the lowest number that is greater than what was previously in that square. So if the previous chosen square had a 4, now start checking the numbers 5-9. If these all cause conflicts, then repeat step 3 again.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 40,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 41,\n            columnNumber: 13\n          }, this), \"Step 4: Repeat\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 43,\n            columnNumber: 13\n          }, this), \"Start again at step 1 until you've filled in all the squares. If there is no solution then reset all the squares back to 0.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 15,\n          columnNumber: 11\n        }, this);\n\n      case 2:\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [\"Hill Climbing is an example of a greedy algorithm, meaning that at each step in the algorithm, it chooses the option that maximizes its short-term gain to the next step.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 55,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 56,\n            columnNumber: 13\n          }, this), \"Step 1: Initialize\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 58,\n            columnNumber: 13\n          }, this), \"Fill all of the 3x3 squares with the numbers 1-9 in a random arrangement so that there are no duplicates in the 3x3 squares. There will be conflicts in the rows and columns.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 62,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 63,\n            columnNumber: 13\n          }, this), \"Step 2: Count Error\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 65,\n            columnNumber: 13\n          }, this), \"For each conflict in the grid, increase the total Error.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 67,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 68,\n            columnNumber: 13\n          }, this), \"Step 3: Switch Squares\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 70,\n            columnNumber: 13\n          }, this), \"Choose two random 1x1 squares in the same 3x3 square. If switching their numbers lowers the total Error in the grid, then make the switch. Otherwise do not.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 74,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 75,\n            columnNumber: 13\n          }, this), \"Step 4: Repeat\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 77,\n            columnNumber: 13\n          }, this), \"Repeat steps 2 and 3 a lot of times or until the error becomes 0.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 79,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 80,\n            columnNumber: 13\n          }, this), \"This implementation looks at around 50000 moves, but quickly reaches a point where there aren't any moves that will lower the error, even though the grid is not solved. This is called a \\\"local minimum\\\" in the error, but it is not the \\\"absolute minimum\\\" of 0 error that we want. To get unstuck from this local minimum, we need to allow the error to increase sometimes, like in Simulated Annealing.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 51,\n          columnNumber: 11\n        }, this);\n\n      case 3:\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [\"Simulated Annealing is based on how molten metals cool into solid form.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 95,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 96,\n            columnNumber: 13\n          }, this), \"Step 1: Initialize\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 98,\n            columnNumber: 13\n          }, this), \"Fill all of the 3x3 squares with the numbers 1-9 in a random arrangement so that there are no duplicates in the 3x3 squares. There will be conflicts in the rows and columns.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 102,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 103,\n            columnNumber: 13\n          }, this), \"Step 2: Count Error\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 105,\n            columnNumber: 13\n          }, this), \"For each conflict in the grid, increase the total Error.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 107,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 108,\n            columnNumber: 13\n          }, this), \"Step 3: Switch Squares\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 110,\n            columnNumber: 13\n          }, this), \"Choose two random 1x1 squares in the same 3x3 square. If switching their numbers lowers the total Error in the grid, then make the switch. If switching their numbers increases the total Error, then there is a chance to make the switch. At the beginning this chance is around 80% but it drops over time to around 0% at the end.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 116,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 117,\n            columnNumber: 13\n          }, this), \"Step 4: Repeat\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 119,\n            columnNumber: 13\n          }, this), \"Repeat steps 2 and 3 a lot of times or until the error becomes 0.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 121,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 122,\n            columnNumber: 13\n          }, this), \"Simulated Annealing is much like Hill Climbing, but it allows the board to change a lot more at the beginning and \\\"cool\\\" into a solution with less errors. This helps the algorithm break out of local minima in the error that Hill Climbing gets stuck at. If you run both of these a few times, you'll see that Hill Climbing usually ends with around 10 errors, but Simulated Annealing usually ends with 2 or 3, which is much better.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 92,\n          columnNumber: 11\n        }, this);\n\n      case 4:\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [\"The genetic algorithm replicates natural selection in organisms.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 137,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 138,\n            columnNumber: 13\n          }, this), \"Step 1: Initialize\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 140,\n            columnNumber: 13\n          }, this), \"Duplicate the initial board 1000 times and randomly set the 0s to be any number 1-9. This is our initial population.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 143,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 144,\n            columnNumber: 13\n          }, this), \"Step 2: Reproduction\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 146,\n            columnNumber: 13\n          }, this), \"Choose two \\\"parent\\\" boards from the current population. Boards with lower errors get chosen to be parents more often. This reflects natural selection choosing more fit individuals to reproduce more. Create a new \\\"child\\\" board by randomly mixing the values of the two parents. This new board becomes a member of the child population. Make 1000 children in this way.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 153,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 154,\n            columnNumber: 13\n          }, this), \"Step 3: Mutation\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 156,\n            columnNumber: 13\n          }, this), \"In each child, there is a small chance that any of its values will randomly change to a different value. This reflects gene mutation in organisms.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 160,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 161,\n            columnNumber: 13\n          }, this), \"Step 4: Repeat\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 163,\n            columnNumber: 13\n          }, this), \"The child population becomes the new parent population. Then repeat Steps 2 and 3. In our implementation we make 1000 generations.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 166,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 167,\n            columnNumber: 13\n          }, this), \"While there are 1000 boards in each generation, I am only showing you one board per generation.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 135,\n          columnNumber: 11\n        }, this);\n\n      default:\n        return \"Choose an algorithm!\";\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"span\", {\n      className: \"About\",\n      children: this.chooseAbout(this.props.selectedAlg)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 180,\n      columnNumber: 7\n    }, this);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/hp/Desktop/Trapping_Water/my-app/src/About.js"],"names":["React","Component","About","constructor","props","state","chooseAbout","bind","alg","render","selectedAlg"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\"\r\nimport \"./About.css\"\r\n\r\nexport default class About extends Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.state = {}\r\n    this.chooseAbout = this.chooseAbout.bind(this)\r\n  }\r\n\r\n  chooseAbout(alg) {\r\n    switch (alg) {\r\n      case 1:\r\n        return (\r\n          <div>\r\n            Backtracking is essentially structured guessing until you find a\r\n            solution that works.\r\n            <br></br>\r\n            <br></br>\r\n            Step 1: Choose 1x1 Square\r\n            <br></br>\r\n            Here we choose the top-left-most 1x1 square whose value is 0.\r\n            <br></br>\r\n            <br></br>\r\n            Step 2: Choose Number\r\n            <br></br>A conflict is when a the number in a 1x1 square already\r\n            appears in the same row, column, or 3x3 square. Choose the lowest\r\n            number 1-9 that doesn't cause a conflict and put it in the current\r\n            chosen square. If all of the numbers 1-9 cause conflicts in the\r\n            current square then go to step 3. Otherwise skip step 3 and go to\r\n            step 4.\r\n            <br></br>\r\n            <br></br>\r\n            Step 3: Backtrack\r\n            <br></br>\r\n            Back up to the previous chosen square. Chose the lowest number that\r\n            is greater than what was previously in that square. So if the\r\n            previous chosen square had a 4, now start checking the numbers 5-9.\r\n            If these all cause conflicts, then repeat step 3 again.\r\n            <br></br>\r\n            <br></br>\r\n            Step 4: Repeat\r\n            <br></br>\r\n            Start again at step 1 until you've filled in all the squares. If\r\n            there is no solution then reset all the squares back to 0.\r\n          </div>\r\n        )\r\n\r\n      case 2:\r\n        return (\r\n          <div>\r\n            Hill Climbing is an example of a greedy algorithm, meaning that at\r\n            each step in the algorithm, it chooses the option that maximizes its\r\n            short-term gain to the next step.\r\n            <br></br>\r\n            <br></br>\r\n            Step 1: Initialize\r\n            <br></br>\r\n            Fill all of the 3x3 squares with the numbers 1-9 in a random\r\n            arrangement so that there are no duplicates in the 3x3 squares.\r\n            There will be conflicts in the rows and columns.\r\n            <br></br>\r\n            <br></br>\r\n            Step 2: Count Error\r\n            <br></br>\r\n            For each conflict in the grid, increase the total Error.\r\n            <br></br>\r\n            <br></br>\r\n            Step 3: Switch Squares\r\n            <br></br>\r\n            Choose two random 1x1 squares in the same 3x3 square. If switching\r\n            their numbers lowers the total Error in the grid, then make the\r\n            switch. Otherwise do not.\r\n            <br></br>\r\n            <br></br>\r\n            Step 4: Repeat\r\n            <br></br>\r\n            Repeat steps 2 and 3 a lot of times or until the error becomes 0.\r\n            <br></br>\r\n            <br></br>\r\n            This implementation looks at around 50000 moves, but quickly reaches\r\n            a point where there aren't any moves that will lower the error, even\r\n            though the grid is not solved. This is called a \"local minimum\" in\r\n            the error, but it is not the \"absolute minimum\" of 0 error that we\r\n            want. To get unstuck from this local minimum, we need to allow the\r\n            error to increase sometimes, like in Simulated Annealing.\r\n          </div>\r\n        )\r\n\r\n      case 3:\r\n        return (\r\n          <div>\r\n            Simulated Annealing is based on how molten metals cool into solid\r\n            form.\r\n            <br></br>\r\n            <br></br>\r\n            Step 1: Initialize\r\n            <br></br>\r\n            Fill all of the 3x3 squares with the numbers 1-9 in a random\r\n            arrangement so that there are no duplicates in the 3x3 squares.\r\n            There will be conflicts in the rows and columns.\r\n            <br></br>\r\n            <br></br>\r\n            Step 2: Count Error\r\n            <br></br>\r\n            For each conflict in the grid, increase the total Error.\r\n            <br></br>\r\n            <br></br>\r\n            Step 3: Switch Squares\r\n            <br></br>\r\n            Choose two random 1x1 squares in the same 3x3 square. If switching\r\n            their numbers lowers the total Error in the grid, then make the\r\n            switch. If switching their numbers increases the total Error, then\r\n            there is a chance to make the switch. At the beginning this chance\r\n            is around 80% but it drops over time to around 0% at the end.\r\n            <br></br>\r\n            <br></br>\r\n            Step 4: Repeat\r\n            <br></br>\r\n            Repeat steps 2 and 3 a lot of times or until the error becomes 0.\r\n            <br></br>\r\n            <br></br>\r\n            Simulated Annealing is much like Hill Climbing, but it allows the\r\n            board to change a lot more at the beginning and \"cool\" into a\r\n            solution with less errors. This helps the algorithm break out of\r\n            local minima in the error that Hill Climbing gets stuck at. If you\r\n            run both of these a few times, you'll see that Hill Climbing usually\r\n            ends with around 10 errors, but Simulated Annealing usually ends\r\n            with 2 or 3, which is much better.\r\n          </div>\r\n        )\r\n\r\n      case 4:\r\n        return (\r\n          <div>\r\n            The genetic algorithm replicates natural selection in organisms.\r\n            <br></br>\r\n            <br></br>\r\n            Step 1: Initialize\r\n            <br></br>\r\n            Duplicate the initial board 1000 times and randomly set the 0s to be\r\n            any number 1-9. This is our initial population.\r\n            <br></br>\r\n            <br></br>\r\n            Step 2: Reproduction\r\n            <br></br>\r\n            Choose two \"parent\" boards from the current population. Boards with\r\n            lower errors get chosen to be parents more often. This reflects\r\n            natural selection choosing more fit individuals to reproduce more.\r\n            Create a new \"child\" board by randomly mixing the values of the two\r\n            parents. This new board becomes a member of the child population.\r\n            Make 1000 children in this way.\r\n            <br></br>\r\n            <br></br>\r\n            Step 3: Mutation\r\n            <br></br>\r\n            In each child, there is a small chance that any of its values will\r\n            randomly change to a different value. This reflects gene mutation in\r\n            organisms.\r\n            <br></br>\r\n            <br></br>\r\n            Step 4: Repeat\r\n            <br></br>\r\n            The child population becomes the new parent population. Then repeat\r\n            Steps 2 and 3. In our implementation we make 1000 generations.\r\n            <br></br>\r\n            <br></br>\r\n            While there are 1000 boards in each generation, I am only showing\r\n            you one board per generation.\r\n          </div>\r\n        )\r\n\r\n      default:\r\n        return \"Choose an algorithm!\"\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <span className=\"About\">{this.chooseAbout(this.props.selectedAlg)}</span>\r\n    )\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}