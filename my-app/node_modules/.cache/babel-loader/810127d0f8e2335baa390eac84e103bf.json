{"ast":null,"code":"/**\r\n * @param {number[][]} heightMap\r\n * @return {number}\r\n */\nvar trapRainWater = function (heightMap, moves) {\n  let h = heightMap.length;\n  let w = heightMap[0].length;\n  let numZeros = (w - 2) * (h - 2); //number of tiles left to be traversed\n\n  let waterLevel = 0; //current water level within borders\n\n  let minHeight; //minimum height of border tiles\n\n  let currMoves = [];\n  let total = 0; //total is the amount of water that can be held\n  //check for too small of a matrix\n\n  if (h < 3 || w < 3) {\n    console.log(\"YEs\");\n    return {\n      moves: [],\n      solvable: false\n    };\n  }\n\n  let traversed = []; //record of tiles that have been traversed\n\n  for (var i = 0; i < h; i++) {\n    traversed[i] = [];\n\n    for (var j = 0; j < w; j++) {\n      traversed[i][j] = 0;\n    }\n  } //add outer tiles of heightMap as border\n\n\n  let borderCoords = []; //coordinates of border tiles. index is row, value is column.\n\n  for (let i = 0; i < h; i++) {\n    borderCoords[i] = [];\n  } //traverse all border tiles and corners\n  //top and bottom\n\n\n  for (let i = 1; i < w - 1; i++) {\n    borderCoords[0].push(i);\n    borderCoords[h - 1].push(i);\n    traversed[0][i] = 1;\n    traversed[h - 1][i] = 1; //add these to moves\n\n    currMoves.push([[0], [i]], [[h - 1], [i]]);\n  } //right and left sides\n\n\n  for (let j = 1; j < h - 1; j++) {\n    borderCoords[j].push(0);\n    borderCoords[j].push(w - 1);\n    traversed[j][0] = 1;\n    traversed[j][w - 1] = 1;\n    currMoves.push([[j], [0]], [[j], [w - 1]]);\n  } //add initial border to moves\n\n\n  moves.push({\n    currStep: 0,\n    currMoves: currMoves,\n    total: total,\n    waterLevel: waterLevel\n  });\n  currMoves = []; //corners\n\n  traversed[0][0] = 1;\n  traversed[0][w - 1] = 1;\n  traversed[h - 1][0] = 1;\n  traversed[h - 1][w - 1] = 1;\n  currMoves.push([[0], [0]], [[0], [w - 1]], [[h - 1], [0]], [[h - 1], [w - 1]]);\n  moves.push({\n    currStep: 0,\n    currMoves: currMoves,\n    total: total,\n    waterLevel: waterLevel\n  });\n  currMoves = []; //main loop\n\n  while (numZeros !== 0) {\n    //if new minHeight is more than old, add (newMinHeight - OldMinHeight)*numZerosY\n    for (let i = 0; i < borderCoords.length; i++) {\n      if (borderCoords[i].length > 0) {\n        minHeight = heightMap[i][borderCoords[i][0]];\n        break;\n      }\n    }\n\n    for (let i = 0; i < borderCoords.length; i++) {\n      for (let j = 0; j < borderCoords[i].length; j++) {\n        if (heightMap[i][borderCoords[i][j]] < minHeight) {\n          minHeight = heightMap[i][borderCoords[i][j]];\n        }\n      }\n    }\n\n    if (minHeight > waterLevel) {\n      total += (minHeight - waterLevel) * numZeros;\n      waterLevel = minHeight;\n    } //find lowest border tile\n\n\n    let mini, minj;\n\n    for (let i = 0; i < h; i++) {\n      for (let j = 0; j < borderCoords[i].length; j++) {\n        if (heightMap[i][borderCoords[i][j]] === minHeight) {\n          mini = i;\n          minj = borderCoords[i][j];\n          break;\n        }\n      }\n    } //add lowest border node to moves\n\n\n    currMoves.push([mini, minj]);\n    moves.push({\n      currStep: 1,\n      currMoves: currMoves,\n      total: total,\n      waterLevel: waterLevel\n    });\n    currMoves = []; //get 0 tile next to lowest border tile\n\n    let nextTile = checkNeighbor(mini, minj, 0); //We have our new tile at lowestCoords\n    //update traversed\n\n    traversed[nextTile[0]][nextTile[1]] = 1; //update numZeros\n\n    numZeros -= 1; //remove rock of nextTile from total\n\n    if (heightMap[nextTile[0]][nextTile[1]] <= waterLevel) {\n      total -= heightMap[nextTile[0]][nextTile[1]];\n    } else {\n      total -= waterLevel;\n    } //add nextTile to border\n\n\n    borderCoords[nextTile[0]].push(nextTile[1]);\n    currMoves.push([nextTile[0], nextTile[1]]);\n    moves.push({\n      currStep: 2,\n      currMoves: currMoves,\n      total: total,\n      waterLevel: waterLevel\n    });\n    currMoves = []; //check neighbors of new border tile, if they're no longer next to a 0 tile, then remove them. also check nextTile\n    //above\n\n    let bordi = nextTile[0] - 1;\n    let bordj = nextTile[1];\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //below\n\n\n    bordi = nextTile[0] + 1;\n    bordj = nextTile[1];\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //left\n\n\n    bordi = nextTile[0];\n    bordj = nextTile[1] - 1;\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //right\n\n\n    bordi = nextTile[0];\n    bordj = nextTile[1] + 1;\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //nextTile\n\n\n    bordi = nextTile[0];\n    bordj = nextTile[1];\n\n    if (borderCoords[bordi].includes(bordj)) {\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\n        let indexToRemove = borderCoords[bordi].indexOf(bordj);\n        borderCoords[bordi].splice(indexToRemove, 1);\n        currMoves.push([bordi, bordj]);\n      }\n    } //update moves with border tiles to remove\n\n\n    moves.push({\n      currStep: 3,\n      currMoves: currMoves,\n      total: total,\n      waterLevel: waterLevel\n    });\n    currMoves = [];\n  }\n\n  return moves; //checks neighbors of a tile for a certain value of traversed, returns the first neighbor's coordinates to satisfy\n\n  function checkNeighbor(i, j, value) {\n    //above\n    try {\n      if (traversed[i - 1][j] === value) {\n        return [i - 1, j];\n      }\n    } catch {//neighbor doesn't exist so do nothing. This happens at the edges of heightMap and traversed.\n    } //below\n\n\n    try {\n      if (traversed[i + 1][j] === value) {\n        return [i + 1, j];\n      }\n    } catch {//neighbor doesn't exist so do nothing\n    } //left\n\n\n    try {\n      if (traversed[i][j - 1] === value) {\n        return [i, j - 1];\n      }\n    } catch {//neighbor doesn't exist so do nothing\n    } //right\n\n\n    try {\n      if (traversed[i][j + 1] === value) {\n        return [i, j + 1];\n      }\n    } catch {//neighbor doesn't exist so do nothing\n    }\n\n    return [];\n  }\n};\n\nexport default function initialAlg(heightMap) {\n  let moves = [];\n  moves = trapRainWater(heightMap, moves);\n  return {\n    moves: moves,\n    solvable: true\n  };\n}","map":{"version":3,"sources":["C:/Users/hp/Desktop/Trapping_Water/my-app/src/algorithms/initialAlg.js"],"names":["trapRainWater","heightMap","moves","h","length","w","numZeros","waterLevel","minHeight","currMoves","total","console","log","solvable","traversed","i","j","borderCoords","push","currStep","mini","minj","nextTile","checkNeighbor","bordi","bordj","includes","indexToRemove","indexOf","splice","value","initialAlg"],"mappings":"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","sourcesContent":["/**\r\n * @param {number[][]} heightMap\r\n * @return {number}\r\n */\r\nvar trapRainWater = function (heightMap, moves) {\r\n  let h = heightMap.length\r\n  let w = heightMap[0].length\r\n  let numZeros = (w - 2) * (h - 2) //number of tiles left to be traversed\r\n  let waterLevel = 0 //current water level within borders\r\n  let minHeight //minimum height of border tiles\r\n  let currMoves = []\r\n  let total = 0 //total is the amount of water that can be held\r\n\r\n  //check for too small of a matrix\r\n  if (h < 3 || w < 3) {\r\n    console.log(\"YEs\")\r\n    return { moves: [], solvable: false }\r\n  }\r\n\r\n  let traversed = [] //record of tiles that have been traversed\r\n  for (var i = 0; i < h; i++) {\r\n    traversed[i] = []\r\n    for (var j = 0; j < w; j++) {\r\n      traversed[i][j] = 0\r\n    }\r\n  }\r\n\r\n  //add outer tiles of heightMap as border\r\n  let borderCoords = [] //coordinates of border tiles. index is row, value is column.\r\n  for (let i = 0; i < h; i++) {\r\n    borderCoords[i] = []\r\n  }\r\n\r\n  //traverse all border tiles and corners\r\n  //top and bottom\r\n  for (let i = 1; i < w - 1; i++) {\r\n    borderCoords[0].push(i)\r\n    borderCoords[h - 1].push(i)\r\n    traversed[0][i] = 1\r\n    traversed[h - 1][i] = 1\r\n    //add these to moves\r\n    currMoves.push([[0], [i]], [[h - 1], [i]])\r\n  }\r\n  //right and left sides\r\n  for (let j = 1; j < h - 1; j++) {\r\n    borderCoords[j].push(0)\r\n    borderCoords[j].push(w - 1)\r\n    traversed[j][0] = 1\r\n    traversed[j][w - 1] = 1\r\n    currMoves.push([[j], [0]], [[j], [w - 1]])\r\n  }\r\n  //add initial border to moves\r\n  moves.push({\r\n    currStep: 0,\r\n    currMoves: currMoves,\r\n    total: total,\r\n    waterLevel: waterLevel,\r\n  })\r\n  currMoves = []\r\n\r\n  //corners\r\n  traversed[0][0] = 1\r\n  traversed[0][w - 1] = 1\r\n  traversed[h - 1][0] = 1\r\n  traversed[h - 1][w - 1] = 1\r\n  currMoves.push([[0], [0]], [[0], [w - 1]], [[h - 1], [0]], [[h - 1], [w - 1]])\r\n  moves.push({\r\n    currStep: 0,\r\n    currMoves: currMoves,\r\n    total: total,\r\n    waterLevel: waterLevel,\r\n  })\r\n  currMoves = []\r\n\r\n  //main loop\r\n  while (numZeros !== 0) {\r\n    //if new minHeight is more than old, add (newMinHeight - OldMinHeight)*numZerosY\r\n    for (let i = 0; i < borderCoords.length; i++) {\r\n      if (borderCoords[i].length > 0) {\r\n        minHeight = heightMap[i][borderCoords[i][0]]\r\n        break\r\n      }\r\n    }\r\n    for (let i = 0; i < borderCoords.length; i++) {\r\n      for (let j = 0; j < borderCoords[i].length; j++) {\r\n        if (heightMap[i][borderCoords[i][j]] < minHeight) {\r\n          minHeight = heightMap[i][borderCoords[i][j]]\r\n        }\r\n      }\r\n    }\r\n\r\n    if (minHeight > waterLevel) {\r\n      total += (minHeight - waterLevel) * numZeros\r\n      waterLevel = minHeight\r\n    }\r\n\r\n    //find lowest border tile\r\n    let mini, minj\r\n    for (let i = 0; i < h; i++) {\r\n      for (let j = 0; j < borderCoords[i].length; j++) {\r\n        if (heightMap[i][borderCoords[i][j]] === minHeight) {\r\n          mini = i\r\n          minj = borderCoords[i][j]\r\n          break\r\n        }\r\n      }\r\n    }\r\n    //add lowest border node to moves\r\n    currMoves.push([mini, minj])\r\n    moves.push({\r\n      currStep: 1,\r\n      currMoves: currMoves,\r\n      total: total,\r\n      waterLevel: waterLevel,\r\n    })\r\n    currMoves = []\r\n\r\n    //get 0 tile next to lowest border tile\r\n    let nextTile = checkNeighbor(mini, minj, 0)\r\n\r\n    //We have our new tile at lowestCoords\r\n    //update traversed\r\n    traversed[nextTile[0]][nextTile[1]] = 1\r\n    //update numZeros\r\n    numZeros -= 1\r\n    //remove rock of nextTile from total\r\n    if (heightMap[nextTile[0]][nextTile[1]] <= waterLevel) {\r\n      total -= heightMap[nextTile[0]][nextTile[1]]\r\n    } else {\r\n      total -= waterLevel\r\n    }\r\n    //add nextTile to border\r\n    borderCoords[nextTile[0]].push(nextTile[1])\r\n    currMoves.push([nextTile[0], nextTile[1]])\r\n    moves.push({\r\n      currStep: 2,\r\n      currMoves: currMoves,\r\n      total: total,\r\n      waterLevel: waterLevel,\r\n    })\r\n    currMoves = []\r\n\r\n    //check neighbors of new border tile, if they're no longer next to a 0 tile, then remove them. also check nextTile\r\n    //above\r\n    let bordi = nextTile[0] - 1\r\n    let bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //below\r\n    bordi = nextTile[0] + 1\r\n    bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //left\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1] - 1\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //right\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1] + 1\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //nextTile\r\n    bordi = nextTile[0]\r\n    bordj = nextTile[1]\r\n    if (borderCoords[bordi].includes(bordj)) {\r\n      if (checkNeighbor(bordi, bordj, 0).length === 0) {\r\n        let indexToRemove = borderCoords[bordi].indexOf(bordj)\r\n        borderCoords[bordi].splice(indexToRemove, 1)\r\n        currMoves.push([bordi, bordj])\r\n      }\r\n    }\r\n    //update moves with border tiles to remove\r\n    moves.push({\r\n      currStep: 3,\r\n      currMoves: currMoves,\r\n      total: total,\r\n      waterLevel: waterLevel,\r\n    })\r\n    currMoves = []\r\n  }\r\n\r\n  return moves\r\n\r\n  //checks neighbors of a tile for a certain value of traversed, returns the first neighbor's coordinates to satisfy\r\n  function checkNeighbor(i, j, value) {\r\n    //above\r\n    try {\r\n      if (traversed[i - 1][j] === value) {\r\n        return [i - 1, j]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing. This happens at the edges of heightMap and traversed.\r\n    }\r\n    //below\r\n    try {\r\n      if (traversed[i + 1][j] === value) {\r\n        return [i + 1, j]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n    //left\r\n    try {\r\n      if (traversed[i][j - 1] === value) {\r\n        return [i, j - 1]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n\r\n    //right\r\n    try {\r\n      if (traversed[i][j + 1] === value) {\r\n        return [i, j + 1]\r\n      }\r\n    } catch {\r\n      //neighbor doesn't exist so do nothing\r\n    }\r\n\r\n    return []\r\n  }\r\n}\r\n\r\nexport default function initialAlg(heightMap) {\r\n  let moves = []\r\n\r\n  moves = trapRainWater(heightMap, moves)\r\n\r\n  return { moves: moves, solvable: true }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}