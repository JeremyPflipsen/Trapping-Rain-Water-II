{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\hp\\\\Desktop\\\\Sudoku\\\\my-app\\\\src\\\\About.js\";\nimport React, { Component } from \"react\";\nimport './About.css';\nexport default class About extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.chooseAbout = this.chooseAbout.bind(this);\n  }\n\n  chooseAbout(alg) {\n    switch (alg) {\n      case 1:\n        return /*#__PURE__*/React.createElement(\"div\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 16,\n            columnNumber: 21\n          }\n        }, \"Backtracking is essentially structured guessing until you find a solution that works.\", /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 19,\n            columnNumber: 21\n          }\n        }), /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 20,\n            columnNumber: 21\n          }\n        }), \"Step 1: Choose 1x1 Square\", /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 22,\n            columnNumber: 21\n          }\n        }), \"Here we choose the top-left-most 1x1 square whose value is 0.\", /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 24,\n            columnNumber: 21\n          }\n        }), /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 25,\n            columnNumber: 21\n          }\n        }), \"Step 2: Choose Number\", /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 27,\n            columnNumber: 21\n          }\n        }), \"A conflict is when a the number in a 1x1 square already appears in the same row, column, or 3x3 square. Choose the lowest number 1-9 that doesn't cause a conflict and put it in the current chosen square. If all of the numbers 1-9 cause conflicts in the current square then go to step 3. Otherwise skip step 3 and go to step 4.\", /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 33,\n            columnNumber: 21\n          }\n        }), /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 34,\n            columnNumber: 21\n          }\n        }), \"Step 3: Backtrack\", /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 36,\n            columnNumber: 21\n          }\n        }), \"Back up to the previous chosen square. Chose the lowest number that is greater than what was previously in that square. So if the previous chosen square had a 4, now start checking the numbers 5-9. If these all cause conflicts, then repeat step 3 again.\", /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 41,\n            columnNumber: 21\n          }\n        }), /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 42,\n            columnNumber: 21\n          }\n        }), \"Step 4: Repeat\", /*#__PURE__*/React.createElement(\"br\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 44,\n            columnNumber: 21\n          }\n        }), \"Start again at step 1 until you've filled in all the squares. If there is no solution then reset all the squares back to 0.\");\n\n      case 2:\n        return `Hill Climbing is an example of a greedy algorithm, meaning that\n                    at each step in the algorithm, it chooses the option that maximizes\n                    its short-term gain to the next step. In this implementation, we\n                    define some amount of Error in the grid. The Error is the sum of\n                    all the duplicates in all of the rows and columns, and is shown on\n                    the right side of the screen. The algorithm starts by filling in the\n                    3x3 squares with all the numbers 1-9, so that there are no\n                    duplicates in the 3x3 squares and only duplicates in the rows and\n                    columns. Then the algorithm chooses two random 1x1 squares in a random\n                    3x3 square. If switching their values lowers the number of duplicates\n                    in the rows and columns of the grid, then the error is lower and\n                    the algorithm will make this switch. If the switch increases the\n                    number of errors in the board, then the algorithm will not make this\n                    switch. It looks at around 50000 moves, but quickly reaches a point\n                    where there aren't any moves that will lower the error, even though\n                    the grid is not solved. This is called a \"local minimum\" in the error,\n                    but it is not the \"absolute minimum\" of 0 error that we want.`;\n\n      case 3:\n        return `Simulated Annealing is based on how molten metals cool into solid\n                    form. It is very similar to Hill Climbing. It starts by filling in\n                    all the 3x3 squares with the digits 1-9. Then we define the Error\n                    as the total number of duplicates in the rows and columns. The 3x3\n                    square have no duplicates so the do not contribute to the error.\n                    The algorithm then chooses two random 1x1 square in a random 3x3 \n                    square. If switching their values decreases the total error in the\n                    board, then the algorithm makes this switch. Otherwise, it has a\n                    chance to make this switch and a chance to not make this switch.\n                    At the beginning, there is about an 80% change that the algorithm\n                    will make this \"bad\" switch. Over time, the chance to make a \"bad\"\n                    switch goes down so that by the end there is almost a 0% chance.\n                    In this way, the algorithm is much like Hill Climbing, but it\n                    allows the board to change a lot more at the beginning, and \"cool\"\n                    into a solution with less errors. This helps the algorithm break\n                    out of local minima in the error that Hill Climbing gets stuck\n                    at. If you run both of these a few times, you'll see that Hill\n                    Climbing usually ends with around 10 errors, but Simulated\n                    Annealing usually ends with 2 or 3, which is much better.`;\n\n      case 4:\n        return `The genetic algorithm replicates natural selection in organisms.\n                    It starts off by creating 1000 different random boards. This is\n                    the first generation. It counts the number of errors in the\n                    rows, columns, and 3x3 squares for each board. It then creates a\n                    second generation by making 1000 \"children\" boards from the first\n                    generation. A child is created by selecting two \"parent\" boards\n                    from the first generation and mixing their values together.\n                    Importantly, boards in the first generation with lower errors are\n                    selected as parents more often so that children with similarly \n                    low errors are produced more than children with higher error. In\n                    this way we are \"selecting\" the more fit boards to reproduce more\n                    in the same way nature selects more fit organisms to reproduce more.\n                    Each child also undergoes a mutation process which gives a small\n                    chance for any of its values that it got from its parents to\n                    randomly change to another value. This reflects Gene mutation in\n                    natural selection. When 1000 children have been created, they\n                    become the parents to make the 3rd generation. And those children\n                    become parents to make the 4th generation, and so on. This\n                    algorithm runs for 1000 generations before stopping.`;\n\n      default:\n        return \"Choose an algorithm!\";\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"span\", {\n      className: \"About\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 124,\n        columnNumber: 9\n      }\n    }, this.chooseAbout(this.props.selectedAlg));\n  }\n\n}","map":{"version":3,"sources":["C:/Users/hp/Desktop/Sudoku/my-app/src/About.js"],"names":["React","Component","About","constructor","props","state","chooseAbout","bind","alg","render","selectedAlg"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAO,aAAP;AAEA,eAAe,MAAMC,KAAN,SAAoBD,SAApB,CAA6B;AACxCE,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAa,EAAb;AAEA,SAAKC,WAAL,GAAmB,KAAKA,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,CAAnB;AACD;;AAEHD,EAAAA,WAAW,CAACE,GAAD,EAAM;AACb,YAAQA,GAAR;AACI,WAAK,CAAL;AACI,4BACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iHAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAHA,eAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAJA,4CAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UANA,gFAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UARA,eASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UATA,wCAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAXA,yVAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAjBA,eAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAlBA,oCAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UApBA,gRAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAzBA,eA0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UA1BA,iCA4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UA5BA,gIADJ;;AAmCJ,WAAK,CAAL;AACI,eACK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAjBgB;;AAoBJ,WAAK,CAAL;AACI,eACK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAnBgB;;AAsBJ,WAAK,CAAL;AACI,eACK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAnBgB;;AAsBJ;AACI,eAAO,sBAAP;AAzGR;AA2GH;;AAEDC,EAAAA,MAAM,GAAG;AACL,wBACA;AAAM,MAAA,SAAS,EAAC,OAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAyB,KAAKH,WAAL,CAAiB,KAAKF,KAAL,CAAWM,WAA5B,CAAzB,CADA;AAGH;;AA1HuC","sourcesContent":["import React, { Component } from \"react\";\r\nimport './About.css'\r\n\r\nexport default class About extends Component{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n        };\r\n        this.chooseAbout = this.chooseAbout.bind(this)\r\n      }\r\n\r\n    chooseAbout(alg) {\r\n        switch (alg) {\r\n            case 1:\r\n                return (\r\n                    <div>\r\n                    Backtracking is essentially structured guessing until you find \r\n                    a solution that works.\r\n                    <br></br>\r\n                    <br></br>\r\n                    Step 1: Choose 1x1 Square\r\n                    <br></br>\r\n                    Here we choose the top-left-most 1x1 square whose value is 0.\r\n                    <br></br>\r\n                    <br></br>\r\n                    Step 2: Choose Number\r\n                    <br></br>\r\n                    A conflict is when a the number in a 1x1 square already appears\r\n                    in the same row, column, or 3x3 square. Choose the lowest number\r\n                    1-9 that doesn't cause a conflict and put it in the current chosen\r\n                    square. If all of the numbers 1-9 cause conflicts in the current square\r\n                    then go to step 3. Otherwise skip step 3 and go to step 4.\r\n                    <br></br>\r\n                    <br></br>\r\n                    Step 3: Backtrack\r\n                    <br></br>\r\n                    Back up to the previous chosen square. Chose the lowest number that\r\n                    is greater than what was previously in that square. So if the previous \r\n                    chosen square had a 4, now start checking the numbers 5-9. If these all\r\n                    cause conflicts, then repeat step 3 again.\r\n                    <br></br>\r\n                    <br></br>\r\n                    Step 4: Repeat\r\n                    <br></br>\r\n                    Start again at step 1 until you've filled in all the squares. If there\r\n                    is no solution then reset all the squares back to 0.\r\n                    </div>\r\n                    )\r\n            \r\n            case 2: \r\n                return (\r\n                    `Hill Climbing is an example of a greedy algorithm, meaning that\r\n                    at each step in the algorithm, it chooses the option that maximizes\r\n                    its short-term gain to the next step. In this implementation, we\r\n                    define some amount of Error in the grid. The Error is the sum of\r\n                    all the duplicates in all of the rows and columns, and is shown on\r\n                    the right side of the screen. The algorithm starts by filling in the\r\n                    3x3 squares with all the numbers 1-9, so that there are no\r\n                    duplicates in the 3x3 squares and only duplicates in the rows and\r\n                    columns. Then the algorithm chooses two random 1x1 squares in a random\r\n                    3x3 square. If switching their values lowers the number of duplicates\r\n                    in the rows and columns of the grid, then the error is lower and\r\n                    the algorithm will make this switch. If the switch increases the\r\n                    number of errors in the board, then the algorithm will not make this\r\n                    switch. It looks at around 50000 moves, but quickly reaches a point\r\n                    where there aren't any moves that will lower the error, even though\r\n                    the grid is not solved. This is called a \"local minimum\" in the error,\r\n                    but it is not the \"absolute minimum\" of 0 error that we want.`\r\n                )\r\n\r\n            case 3: \r\n                return (\r\n                    `Simulated Annealing is based on how molten metals cool into solid\r\n                    form. It is very similar to Hill Climbing. It starts by filling in\r\n                    all the 3x3 squares with the digits 1-9. Then we define the Error\r\n                    as the total number of duplicates in the rows and columns. The 3x3\r\n                    square have no duplicates so the do not contribute to the error.\r\n                    The algorithm then chooses two random 1x1 square in a random 3x3 \r\n                    square. If switching their values decreases the total error in the\r\n                    board, then the algorithm makes this switch. Otherwise, it has a\r\n                    chance to make this switch and a chance to not make this switch.\r\n                    At the beginning, there is about an 80% change that the algorithm\r\n                    will make this \"bad\" switch. Over time, the chance to make a \"bad\"\r\n                    switch goes down so that by the end there is almost a 0% chance.\r\n                    In this way, the algorithm is much like Hill Climbing, but it\r\n                    allows the board to change a lot more at the beginning, and \"cool\"\r\n                    into a solution with less errors. This helps the algorithm break\r\n                    out of local minima in the error that Hill Climbing gets stuck\r\n                    at. If you run both of these a few times, you'll see that Hill\r\n                    Climbing usually ends with around 10 errors, but Simulated\r\n                    Annealing usually ends with 2 or 3, which is much better.`\r\n                )\r\n\r\n            case 4:\r\n                return (\r\n                    `The genetic algorithm replicates natural selection in organisms.\r\n                    It starts off by creating 1000 different random boards. This is\r\n                    the first generation. It counts the number of errors in the\r\n                    rows, columns, and 3x3 squares for each board. It then creates a\r\n                    second generation by making 1000 \"children\" boards from the first\r\n                    generation. A child is created by selecting two \"parent\" boards\r\n                    from the first generation and mixing their values together.\r\n                    Importantly, boards in the first generation with lower errors are\r\n                    selected as parents more often so that children with similarly \r\n                    low errors are produced more than children with higher error. In\r\n                    this way we are \"selecting\" the more fit boards to reproduce more\r\n                    in the same way nature selects more fit organisms to reproduce more.\r\n                    Each child also undergoes a mutation process which gives a small\r\n                    chance for any of its values that it got from its parents to\r\n                    randomly change to another value. This reflects Gene mutation in\r\n                    natural selection. When 1000 children have been created, they\r\n                    become the parents to make the 3rd generation. And those children\r\n                    become parents to make the 4th generation, and so on. This\r\n                    algorithm runs for 1000 generations before stopping.`\r\n                )\r\n            \r\n            default:\r\n                return \"Choose an algorithm!\"\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n        <span className='About'>{this.chooseAbout(this.props.selectedAlg)}</span>\r\n        )\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}