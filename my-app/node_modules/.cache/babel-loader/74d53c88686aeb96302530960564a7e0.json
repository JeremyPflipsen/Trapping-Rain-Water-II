{"ast":null,"code":"function Node(row, col) {\n  return document.getElementById(`node-${row}-${col}`);\n} // Gets a node from the screen\n\n\nexport default function visualizeBacktracking(moves, solvable) {\n  //If the original grid isn't solvable then tell the user and return\n  if (!solvable) {\n    document.getElementById('backtrackHasSolution').innerHTML = 'Duplicate detected. Grid has no solution.';\n    return;\n  } else {\n    document.getElementById('backtrackHasSolution').innerHTML = '';\n  } //Show all the moves\n\n\n  for (let i = 0; i < moves.length; i++) {\n    setTimeout(() => {\n      Node(moves[i][0], moves[i][1]).className = 'node-start'; //color node about to be changed\n    }, 5000 * Math.pow(i, 0.25) - 5000);\n    setTimeout(() => {\n      Node(moves[i][0], moves[i][1]).value = moves[i][2];\n\n      if (moves[i][2] === 0) {\n        Node(moves[i][0], moves[i][1]).className = 'node'; //color visited nodes\n      } else {\n        Node(moves[i][0], moves[i][1]).className = 'node-finish'; //color visited nodes\n      }\n    }, 5000 * Math.pow(i + 1, 0.25) - 5000);\n  } //check if grid has been solved\n\n\n  setTimeout(() => {\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        console.log(Node(row, col).value);\n\n        if (Node(row, col).value === '0') {\n          document.getElementById('backtrackHasSolution').innerHTML = 'Grid does not have a solution :(';\n        }\n      }\n    }\n  }, 5000 * Math.pow(moves.length + 1, 0.25) - 5000);\n}","map":{"version":3,"sources":["C:/Users/hp/Desktop/Sudoku/my-app/src/algorithms/visualizeBacktracking.js"],"names":["Node","row","col","document","getElementById","visualizeBacktracking","moves","solvable","innerHTML","i","length","setTimeout","className","Math","pow","value","console","log"],"mappings":"AAAA,SAASA,IAAT,CAAcC,GAAd,EAAmBC,GAAnB,EAAwB;AACpB,SAAOC,QAAQ,CAACC,cAAT,CAAyB,QAAOH,GAAI,IAAGC,GAAI,EAA3C,CAAP;AACH,C,CAAC;;;AAEF,eAAe,SAASG,qBAAT,CAA+BC,KAA/B,EAAqCC,QAArC,EAA+C;AAC1D;AACA,MAAI,CAACA,QAAL,EAAe;AACXJ,IAAAA,QAAQ,CAACC,cAAT,CAAwB,sBAAxB,EAAgDI,SAAhD,GAA4D,2CAA5D;AACA;AACH,GAHD,MAIK;AACDL,IAAAA,QAAQ,CAACC,cAAT,CAAwB,sBAAxB,EAAgDI,SAAhD,GAA4D,EAA5D;AACH,GARyD,CAU1D;;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAEnCE,IAAAA,UAAU,CAAC,MAAM;AACbX,MAAAA,IAAI,CAACM,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAD,EAAaH,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAb,CAAJ,CAA8BG,SAA9B,GAA0C,YAA1C,CADa,CAC0C;AAC1D,KAFS,EAEP,OAAKC,IAAI,CAACC,GAAL,CAASL,CAAT,EAAW,IAAX,CAAL,GAAsB,IAFf,CAAV;AAGAE,IAAAA,UAAU,CAAC,MAAM;AACbX,MAAAA,IAAI,CAACM,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAD,EAAaH,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAb,CAAJ,CAA8BM,KAA9B,GAAsCT,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAtC;;AACA,UAAIH,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,MAAgB,CAApB,EAAsB;AAClBT,QAAAA,IAAI,CAACM,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAD,EAAaH,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAb,CAAJ,CAA8BG,SAA9B,GAA0C,MAA1C,CADkB,CAC+B;AACpD,OAFD,MAGK;AACDZ,QAAAA,IAAI,CAACM,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAD,EAAaH,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAb,CAAJ,CAA8BG,SAA9B,GAA0C,aAA1C,CADC,CACuD;AAC3D;AACJ,KARS,EAQP,OAAKC,IAAI,CAACC,GAAL,CAASL,CAAC,GAAC,CAAX,EAAa,IAAb,CAAL,GAAwB,IARjB,CAAV;AASH,GAzByD,CA2B1D;;;AACAE,EAAAA,UAAU,CAAC,MAAM;AACb,SAAK,IAAIV,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,CAAxB,EAA2BA,GAAG,EAA9B,EAAkC;AAC9B,WAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,CAAxB,EAA2BA,GAAG,EAA9B,EAAkC;AAC9Bc,QAAAA,OAAO,CAACC,GAAR,CAAYjB,IAAI,CAACC,GAAD,EAAKC,GAAL,CAAJ,CAAca,KAA1B;;AACA,YAAIf,IAAI,CAACC,GAAD,EAAKC,GAAL,CAAJ,CAAca,KAAd,KAAwB,GAA5B,EAAiC;AAC7BZ,UAAAA,QAAQ,CAACC,cAAT,CAAwB,sBAAxB,EAAgDI,SAAhD,GAA4D,kCAA5D;AACH;AACJ;AACJ;AACJ,GATS,EASP,OAAKK,IAAI,CAACC,GAAL,CAASR,KAAK,CAACI,MAAN,GAAa,CAAtB,EAAwB,IAAxB,CAAL,GAAmC,IAT5B,CAAV;AAUH","sourcesContent":["function Node(row, col) {\r\n    return document.getElementById(`node-${row}-${col}`)\r\n} // Gets a node from the screen\r\n\r\nexport default function visualizeBacktracking(moves,solvable) {\r\n    //If the original grid isn't solvable then tell the user and return\r\n    if (!solvable) {\r\n        document.getElementById('backtrackHasSolution').innerHTML = 'Duplicate detected. Grid has no solution.'\r\n        return\r\n    }\r\n    else {\r\n        document.getElementById('backtrackHasSolution').innerHTML = ''\r\n    }\r\n\r\n    //Show all the moves\r\n    for (let i = 0; i < moves.length; i++) {\r\n    \r\n        setTimeout(() => {\r\n            Node(moves[i][0],moves[i][1]).className = 'node-start' //color node about to be changed\r\n        }, 5000*Math.pow(i,0.25)-5000)\r\n        setTimeout(() => {\r\n            Node(moves[i][0],moves[i][1]).value = moves[i][2]\r\n            if (moves[i][2] === 0){\r\n                Node(moves[i][0],moves[i][1]).className = 'node' //color visited nodes\r\n            }\r\n            else {\r\n                Node(moves[i][0],moves[i][1]).className = 'node-finish' //color visited nodes\r\n            }\r\n        }, 5000*Math.pow(i+1,0.25)-5000)\r\n    }\r\n\r\n    //check if grid has been solved\r\n    setTimeout(() => {\r\n        for (let row = 0; row < 9; row++) {\r\n            for (let col = 0; col < 9; col ++){\r\n                console.log(Node(row,col).value)\r\n                if (Node(row,col).value === '0') {\r\n                    document.getElementById('backtrackHasSolution').innerHTML = 'Grid does not have a solution :('\r\n                }\r\n            }\r\n        }\r\n    }, 5000*Math.pow(moves.length+1,0.25)-5000)\r\n}"]},"metadata":{},"sourceType":"module"}